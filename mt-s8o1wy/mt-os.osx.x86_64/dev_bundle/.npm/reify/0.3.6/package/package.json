{"name":"reify","version":"0.3.6","main":"node/index.js","browser":"lib/empty.js","author":{"name":"Ben Newman","email":"ben@benjamn.com"},"description":"Enable ECMAScript 2015 modules in Node today. No caveats. Full stop.","repository":{"type":"git","url":"git+https://github.com/benjamn/reify.git"},"keywords":["ecmascript","modules","import","export","commonjs","require","exports","node"],"license":"MIT","homepage":"https://github.com/benjamn/reify#readme","bugs":{"url":"https://github.com/benjamn/reify/issues"},"scripts":{"test":"test/run.sh"},"dependencies":{"acorn":"~3.2.0","ast-types":"~0.8.16","magic-string":"~0.15.0"},"devDependencies":{"mocha":"~2.5.3"},"readme":"# re•i•fy <sub>_verb, transitive_</sub> &nbsp; [![Build Status](https://travis-ci.org/benjamn/reify.svg?branch=master)](https://travis-ci.org/benjamn/reify)\n\n**re•i•fied** <sub>past</sub> &nbsp; **re•i•fies** <sub>present</sub> &nbsp; **re•i•fy•ing** <sub>participle</sub> &nbsp; **re•i•fi•ca•tion** <sub>noun</sub> &nbsp; **re•i•fi•er** <sub>noun</sub>\n\n  1. to make (something abstract) more concrete or real<br>\n     _\"these instincts are, in humans, reified as verbal constructs\"_\n  2. to regard or treat (an idea, concept, etc.) as if having material existence\n  3. **to enable [ECMAScript 2015 modules](http://www.2ality.com/2014/09/es6-modules-final.html) in *any* version of [Node.js](https://nodejs.org)**\n\nUsage\n---\n\n  1. Run `npm install --save reify` in your package or app directory. The\n     `--save` is important because reification only applies to modules in\n     packages that explicitly depend on the `reify` package.\n  2. Call `require(\"reify\")` before importing modules that contain `import`\n     and `export` declarations.\n\nYou can also easily `reify` the Node REPL:\n\n```sh\n% node\n> require(\"reify/repl\")\n{}\n> import { strictEqual } from \"assert\"\n> strictEqual(2 + 2, 5)\nAssertionError: 4 === 5\n    at repl:1:1\n    at REPLServer.defaultEval (repl.js:272:27)\n  ...\n```\n\nHow it works\n---\n\nCode generated by the `reify` compiler relies on a [simple runtime\nAPI](lib/runtime.js) that can be explained through a series of\nexamples. While you do not have to write this API by hand, it is designed\nto be easily human readable and writable, in part because that makes it\neasier to explain.\n\nI will explain the `Module.prototype.import` method first, then the\n`Module.prototype.export` method after that. Note that this `Module` is\nthe constructor of the CommonJS `module` object, and the `import` and\n`export` methods are custom additions to `Module.prototype`.\n\n### `module.import(id, setters)`\n\nHere we go:\n\n```js\nimport a, { b, c as d } from \"./module\";\n```\n\nbecomes\n\n```js\n// Local symbols are declared as ordinary variables.\nlet a, b, d;\nmodule.import(\"./module\", {\n  // The keys of this object literal are the names of exported symbols.\n  // The values are setter functions that take new values and update the\n  // local variables.\n  default: value => { a = value; },\n  b: value => { b = value; },\n  c: value => { d = value; },\n});\n```\n\nAll setter functions are called synchronously before `module.import`\nreturns, with whatever values are immediately available. However, when\nthere are import cycles, some setter functions may be called again, when\nthe exported values change. Calling these setter functions one or more\ntimes is the key to implementing [*live\nbindings*](http://www.2ality.com/2015/07/es6-module-exports.html), as\nrequired by the ECMAScript 2015 specification.\n\nWhile most setter functions only need to know the value of the exported\nsymbol, the name of the symbol is also provided as a second parameter\nafter the value. This parameter becomes important for `*` imports (and `*`\nexports, but we'll get to that a bit later):\n\n```js\nimport * as utils from \"./utils\";\n```\nbecomes\n```js\nlet utils = {};\nmodule.import(\"./utils\", {\n  \"*\": (value, name) => {\n    utils[name] = value;\n  }\n});\n```\n\nThe setter function for `*` imports is called once for each symbol name\nexported from the `\"./utils\"` module. If any individual value happens to\nchange after the call to `module.import`, the setter function will be\ncalled again to update that particular value. This approach ensures that\nthe actual `exports` object is never exposed to the caller of\n`module.import`.\n\nNotice that this compilation strategy works equally well no matter where\nthe `import` declaration appears:\n\n```js\nif (condition) {\n  import { a as b } from \"./c\";\n  console.log(b);\n}\n```\nbecomes\n```js\nif (condition) {\n  let b;\n  module.import(\"./c\", {\n    a: value => { b = value; }\n  });\n  console.log(b);\n}\n```\n\nSee [`WHY_NEST_IMPORTS.md`](WHY_NEST_IMPORTS.md) for a much more detailed\ndiscussion of why nested `import` declarations are worthwhile.\n\n### `module.export(getters)`\n\nWhat about `export` declarations? One option would be to transform them into\nCommonJS code that updates the `exports` object, since interoperability\nwith Node and CommonJS is certainly a goal of this approach.\n\nHowever, if `Module.prototype.import` takes a module identifier and a map\nof *setter* functions, then it seems natural to have a\n`Module.prototype.export` method that registers *getter* functions. Given\nthese getter functions, whenever `module.import(id, ...)` is called by a\nparent module, the getters for the `id` module will run, updating its\n`module.exports` object, so that the `module.import` method has access to\nthe latest exported values.\n\nThe `module.export` method is called with a single object literal whose\nkeys are exported symbol names and whose values are getter functions for\nthose exported symbols. So, for example,\n\n```js\nexport const a = \"a\", b = \"b\", ...;\n```\n\nbecomes\n\n```js\nmodule.export({\n  a: () => a,\n  b: () => b,\n  ...\n});\nconst a = \"a\", b = \"b\", ...;\n```\n\nThis code registers getter functions for the variables `a`, `b`, ..., so\nthat `module.import` can easily retrieve the latest values of those\nvariables at any time. It's important that we register getter functions\nrather than storing computed values, so that other modules always can\nimport the newest values.\n\nExport remapping works, too:\n\n```js\nlet c = 123;\nexport { c as see }\n```\n\nbecomes\n\n```js\nmodule.export({ see: () => c });\nlet c = 123;\n```\n\nNote that the `module.export` call is \"hoisted\" to the top of the block\nwhere it appears. This is safe because the getter functions work equally\nwell anywhere in the scope where the exported variable is declared, and\nimportant to ensure getters are registered as early as possible.\n\nWhat about `export default` declarations? It would be a mistake to defer\nevaluation of the `default` expression until later, so wrapping it in a\ngetter function is not exactly what we want.\n\nThe important point to understand here is that `module.import` does not\nassume a getter function has been registered by `module.export` for every\nimported symbol. Instead, `parentModule.import` only really cares about\nthe contents of `childModule.exports`. While the `childModule.export`\nmethod helps keep `childModule.exports` up to date, that level of\nsophistication isn't strictly necessary in every situation, and `default`\nexports are one such situation:\n\n```js\nexport default getDefault();\n```\n\nsimply becomes\n\n```js\nexports.default = getDefault();\n```\n\n### `module.runModuleSetters()`\n\nNow, suppose you change the value of an exported local variable after the\nmodule has finished loading. Then you need to let the module system know\nabout the update, and that's where `module.runModuleSetters` comes in. The\nmodule system calls this method on your behalf whenever a module finishes\nloading, but you can also call it manually, or simply let `reify` generate\ncode that calls `module.runModuleSetters` for you whenever you assign to\nan exported local variable.\n\nCalling `module.runModuleSetters()` with no arguments causes any setters\nthat depend on the current module to be rerun, *but only if the value a\nsetter would receive is different from the last value passed to the\nsetter*.\n\nIf you pass an argument to `module.runModuleSetters`, the value of that\nargument will be returned as-is, so that you can easily wrap assignment\nexpressions with calls to `module.runModuleSetters`:\n\n```js\nexport let value = 0;\nexport function increment(by) {\n  return value += by;\n};\n```\n\nshould become\n\n```js\nmodule.export({\n  value: () => value,\n  increment: () => increment,\n});\nlet value = 0;\nfunction increment(by) {\n  return module.runModuleSetters(value += by);\n};\n```\n\nNote that `module.runModuleSetters(argument)` does not actually use\n`argument`. However, by having `module.runModuleSetters(argument)` return\n`argument` unmodified, we can run setters immediately after the assignment\nwithout interfering with evaluation of the larger expression.\n\nBecause `module.runModuleSetters` runs any setters that have new values,\nit's also useful for potentially risky expressions that are difficult to\nanalyze statically:\n\n```js\nexport let value = 0;\n\nfunction runCommand(command) {\n  // This picks up any new values of any exported local variables that may\n  // have been modified by eval.\n  return module.runModuleSetters(eval(command));\n}\n\nrunCommand(\"value = 1234\");\n```\n\n### `export`s that are really `import`s\n\nWhat about `export ... from \"./module\"` declarations? The key insight here\nis that **`export` declarations with a `from \"...\"` clause are really just\n`import` declarations that update the `exports` object instead of updating\nlocal variables**:\n\n```js\nexport { a, b as c } from \"./module\";\n```\nbecomes\n```js\nmodule.import(\"./module\", {\n  a: value => { exports.a = value; },\n  b: value => { exports.c = value; },\n});\n```\n\nThis strategy cleanly generalizes to `export * from \"...\"` declarations:\n\n```js\nexport * from \"./module\";\n```\nbecomes\n```js\nmodule.import(\"./module\", {\n  \"*\": (value, name) => {\n    exports[name] = value;\n  }\n});\n```\n\nWhile these examples have not covered every possible syntax for `import`\nand `export` declarations, I hope they provide the intuition necessary to\nimagine how any declaration could be compiled.\n\nWhen I have some time, I hope to implement a [live-compiling text\neditor](https://github.com/benjamn/reify/issues/15) to enable\nexperimentation.\n","readmeFilename":"README.md","_id":"reify@0.3.6","_shasum":"053ca2b502bed6dd94d974a81b312f47e34bf652","_resolved":"https://registry.npmjs.org/reify/-/reify-0.3.6.tgz","_from":"https://registry.npmjs.org/reify/-/reify-0.3.6.tgz"}