{"version":3,"sources":["/tools/shell-client.js"],"names":["assert","require","fs","path","net","eachline","chalk","EOL","EXITING_MESSAGE","getInfoFile","shellDir","join","exports","connect","Client","self","ok","exitOnClose","firstTimeConnecting","connected","reconnectCount","Cp","prototype","reconnect","delay","console","error","yellow","reconnectTimer","setTimeout","infoFile","readFile","err","json","info","JSON","parse","status","reason","process","exit","setUpSocket","port","key","setUpSocketForSingleUse","sock","on","inputBuffers","stdin","push","buffer","write","stringify","evaluateAndExit","command","Buffer","concat","toString","terminal","outputBuffers","output","code","stdout","result","isTTY","resume","onConnect","env","EMACS","stderr","shellBanner","pipe","setRawMode","onClose","tearDown","onError","unpipe","removeListener","end","line","indexOf","bannerLines","green"],"mappings":"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","file":"tools/shell-client.js.map","sourcesContent":["var assert = require(\"assert\");\nvar fs = require(\"fs\");\nvar path = require(\"path\");\nvar net = require(\"net\");\nvar eachline = require(\"eachline\");\nvar chalk = require(\"chalk\");\nvar EOL = require(\"os\").EOL;\n\n// These two values (EXITING_MESSAGE and getInfoFile) must match the\n// values used by the shell-server package.\nvar EXITING_MESSAGE = \"Shell exiting...\";\nfunction getInfoFile(shellDir) {\n  return path.join(shellDir, \"info.json\");\n}\n\n// Invoked by the process running `meteor shell` to attempt to connect to\n// the server via the socket file.\nexports.connect = function connect(shellDir) {\n  new Client(shellDir).connect();\n};\n\nfunction Client(shellDir) {\n  var self = this;\n  assert.ok(self instanceof Client);\n\n  self.shellDir = shellDir;\n  self.exitOnClose = false;\n  self.firstTimeConnecting = true;\n  self.connected = false;\n  self.reconnectCount = 0;\n}\n\nvar Cp = Client.prototype;\n\nCp.reconnect = function reconnect(delay) {\n  var self = this;\n\n  // Display the \"Server unavailable\" warning only on the third attempt\n  // to reconnect, so it doesn't get shown for successful reconnects.\n  if (++self.reconnectCount === 3) {\n    console.error(chalk.yellow(\n      \"Server unavailable (waiting to reconnect)\"\n    ));\n  }\n\n  if (!self.reconnectTimer) {\n    self.reconnectTimer = setTimeout(function() {\n      delete self.reconnectTimer;\n      self.connect();\n    }, delay || 100);\n  }\n};\n\nCp.connect = function connect() {\n  var self = this;\n  var infoFile = getInfoFile(self.shellDir);\n\n  fs.readFile(infoFile, \"utf8\", function(err, json) {\n    if (err) {\n      return self.reconnect();\n    }\n\n    try {\n      var info = JSON.parse(json);\n    } catch (err) {\n      return self.reconnect();\n    }\n\n    if (info.status !== \"enabled\") {\n      if (self.firstTimeConnecting) {\n        return self.reconnect();\n      }\n\n      if (info.reason) {\n        console.error(info.reason);\n      }\n\n      console.error(EXITING_MESSAGE);\n      process.exit(0);\n    }\n\n    self.setUpSocket(\n      net.connect(info.port, \"127.0.0.1\"),\n      info.key\n    );\n  });\n};\n\nCp.setUpSocketForSingleUse = function (sock, key) {\n  sock.on(\"connect\", function () {\n    const inputBuffers = [];\n    process.stdin.on(\"data\", buffer => inputBuffers.push(buffer));\n    process.stdin.on(\"end\", () => {\n      sock.write(JSON.stringify({\n        evaluateAndExit: {\n          // Make sure the entire command is written as a string within a\n          // JSON object, so that the server can easily tell when it has\n          // received the whole command.\n          command: Buffer.concat(inputBuffers).toString(\"utf8\")\n        },\n        terminal: false,\n        key: key\n      }) + \"\\n\");\n    });\n  });\n\n  const outputBuffers = [];\n  sock.on(\"data\", buffer => outputBuffers.push(buffer));\n  sock.on(\"close\", function () {\n    var output = JSON.parse(Buffer.concat(outputBuffers));\n    if (output.error) {\n      console.error(output.error);\n      process.exit(output.code);\n    } else {\n      process.stdout.write(JSON.stringify(output.result) + \"\\n\");\n      process.exit(0);\n    }\n  });\n};\n\nCp.setUpSocket = function setUpSocket(sock, key) {\n  const self = this;\n\n  if (! process.stdin.isTTY) {\n    return self.setUpSocketForSingleUse(sock, key);\n  }\n\n  // Put STDIN into \"flowing mode\":\n  // http://nodejs.org/api/stream.html#stream_compatibility_with_older_node_versions\n  process.stdin.resume();\n\n  function onConnect() {\n    self.firstTimeConnecting = false;\n    self.reconnectCount = 0;\n    self.connected = true;\n\n    // Sending a JSON-stringified options object (even just an empty\n    // object) over the socket is required to start the REPL session.\n    sock.write(JSON.stringify({\n      terminal: ! process.env.EMACS,\n      key: key\n    }) + \"\\n\");\n\n    process.stderr.write(shellBanner());\n    process.stdin.pipe(sock);\n    if (process.stdin.setRawMode) { // https://github.com/joyent/node/issues/8204\n      process.stdin.setRawMode(true);\n    }\n  }\n\n  function onClose() {\n    tearDown();\n\n    // If we received the special EXITING_MESSAGE just before the socket\n    // closed, then exit the shell instead of reconnecting.\n    if (self.exitOnClose) {\n      process.exit(0);\n    } else {\n      self.reconnect();\n    }\n  }\n\n  function onError(err) {\n    tearDown();\n    self.reconnect();\n  }\n\n  function tearDown() {\n    self.connected = false;\n    if (process.stdin.setRawMode) { // https://github.com/joyent/node/issues/8204\n      process.stdin.setRawMode(false);\n    }\n    process.stdin.unpipe(sock);\n    sock.unpipe(process.stdout);\n    sock.removeListener(\"connect\", onConnect);\n    sock.removeListener(\"close\", onClose);\n    sock.removeListener(\"error\", onError);\n    sock.end();\n  }\n\n  sock.pipe(process.stdout);\n\n  eachline(sock, \"utf8\", function(line) {\n    self.exitOnClose = line.indexOf(EXITING_MESSAGE) >= 0;\n  });\n\n  sock.on(\"connect\", onConnect);\n  sock.on(\"close\", onClose);\n  sock.on(\"error\", onError);\n};\n\nfunction shellBanner() {\n  var bannerLines = [\n    \"\",\n    \"Welcome to the server-side interactive shell!\"\n  ];\n\n  if (! process.env.EMACS) {\n    // Tab completion sadly does not work in Emacs.\n    bannerLines.push(\n      \"\",\n      \"Tab completion is enabled for global variables.\"\n    );\n  }\n\n  bannerLines.push(\n    \"\",\n    \"Type .reload to restart the server and the shell.\",\n    \"Type .exit to disconnect from the server and leave the shell.\",\n    \"Type .help for additional help.\",\n    EOL\n  );\n\n  return chalk.green(bannerLines.join(EOL));\n}\n"]}