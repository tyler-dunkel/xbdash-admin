{"version":3,"sources":["/tools/isobuild/source-arch.js"],"names":["isString","isFunction","WatchSet","reportMissingOption","name","Error","SourceArch","pkg","kind","arch","sourceRoot","getFiles","uses","implies","declaredExports","watchSet","localNodeModulesDirs","Object","create"],"mappings":";AAAA,SAAQA,QAAR,EAAkBC,UAAlB,QAAmC,YAAnC;AACA,SAAQC,QAAR,QAAuB,gBAAvB;;AAEA,SAASC,mBAAT,CAA6BC,IAA7B,EAAmC;AACjC,QAAM,IAAIC,KAAJ,2BAAkCD,IAAlC,+BAAN;AACD;;AAED;;;;;;IAKqBE,U,GACnB,oBAAYC,GAAZ,QAWG;AAAA,MAVDC,IAUC,QAVDA,IAUC;AAAA,MATDC,IASC,QATDA,IASC;AAAA,MARDC,UAQC,QARDA,UAQC;AAAA,MAPDC,QAOC,QAPDA,QAOC;AAAA,uBANDC,IAMC;AAAA,MANDA,IAMC,6BANM,EAMN;AAAA,0BALDC,OAKC;AAAA,MALDA,OAKC,gCALS,EAKT;AAAA,kCAJDC,eAIC;AAAA,MAJDA,eAIC,wCAJiB,IAIjB;AAAA,2BADDC,QACC;AAAA,MADDA,QACC,iCADU,IAAIb,QAAJ,EACV;;AAAA;;AACDF,WAASQ,IAAT,KAAkBL,oBAAoB,MAApB,CAAlB;AACAH,WAASS,IAAT,KAAkBN,oBAAoB,MAApB,CAAlB;AACAH,WAASU,UAAT,KAAwBP,oBAAoB,YAApB,CAAxB;AACAF,aAAWU,QAAX,KAAwBR,oBAAoB,UAApB,CAAxB;;AAEA,OAAKI,GAAL,GAAWA,GAAX;;AAEA;AACA;AACA,OAAKC,IAAL,GAAYA,IAAZ;;AAEA;AACA;AACA,OAAKC,IAAL,GAAYA,IAAZ;;AAEA;AACA,OAAKC,UAAL,GAAkBA,UAAlB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAKE,IAAL,GAAYA,IAAZ;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAKC,OAAL,GAAeA,OAAf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAKF,QAAL,GAAgBA,QAAhB;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAKK,oBAAL,GAA4BC,OAAOC,MAAP,CAAc,IAAd,CAA5B;;AAEA;AACA;AACA,OAAKJ,eAAL,GAAuBA,eAAvB;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAKC,QAAL,GAAgBA,QAAhB;AACD,C;;eApGkBT,U","file":"tools/isobuild/source-arch.js.map","sourcesContent":["import {isString, isFunction} from 'underscore';\nimport {WatchSet} from '../fs/watch.js';\n\nfunction reportMissingOption(name) {\n  throw new Error(`must provide options.${name} when creating SourceArch`);\n}\n\n/**\n * SourceArch\n *\n * Used in ./package-source.js.\n */\nexport default class SourceArch {\n  constructor(pkg, {\n    kind, // required\n    arch, // required\n    sourceRoot, // required\n    getFiles, // required\n    uses = [],\n    implies = [],\n    declaredExports = null,\n    // Do not include the source files in watchSet. They will be added at\n    // compile time when the sources are actually read.\n    watchSet = new WatchSet(),\n  }) {\n    isString(kind) || reportMissingOption('kind');\n    isString(arch) || reportMissingOption('arch');\n    isString(sourceRoot) || reportMissingOption('sourceRoot');\n    isFunction(getFiles) || reportMissingOption('getFiles');\n\n    this.pkg = pkg;\n\n    // Kind of this sourceArchitecture. At the moment, there are really\n    // three options -- package, plugin, and app. We use these in linking.\n    this.kind = kind;\n\n    // The architecture (fully or partially qualified) that can use this\n    // unibuild.\n    this.arch = arch;\n\n    // Absolute path of the root directory of this package or application.\n    this.sourceRoot = sourceRoot;\n\n    // Packages used. The ordering is significant only for determining\n    // import symbol priority (it doesn't affect load order), and a given\n    // package could appear more than once in the list, so code that\n    // consumes this value will need to guard appropriately. Each element\n    // in the array has keys:\n    // - package: the package name\n    // - constraint: the constraint on the version of the package to use,\n    //   as a string (may be null)\n    // - unordered: If true, we don't want the package's imports and we\n    //   don't want to force the package to load before us. We just want\n    //   to ensure that it loads if we load.\n    // - weak: If true, we don't *need* to load the other package, but\n    //   if the other package ends up loaded in the target, it must\n    //   be forced to load before us. We will not get its imports\n    //   or plugins.\n    // It is an error for both unordered and weak to be true, because such\n    // a dependency would have no effect.\n    //\n    // In most places, instead of using 'uses' directly, you want to use\n    // something like compiler.eachUsedUnibuild so you also take into\n    // account implied packages.\n    //\n    // Note that if `package` starts with 'isobuild:', it actually\n    // represents a dependency on a feature of the Isobuild build tool,\n    // not a real package. You need to be aware of this when processing a\n    // `uses` array, which is another reason to use eachUsedUnibuild\n    // instead.\n    this.uses = uses;\n\n    // Packages which are \"implied\" by using this package. If a unibuild X\n    // uses this unibuild Y, and Y implies Z, then X will effectively use\n    // Z as well (and get its imports and plugins).  An array of objects\n    // of the same type as the elements of this.uses (although for now\n    // unordered and weak are not allowed).\n    this.implies = implies;\n\n    // A function that returns the source files for this\n    // architecture. Object with keys `sources` and `assets`, where each\n    // is an array of objects with keys \"relPath\" and \"fileOptions\". Null\n    // if loaded from isopack.\n    //\n    // fileOptions is optional and represents arbitrary options passed to\n    // \"api.addFiles\"; they are made available on to the plugin as\n    // compileStep.fileOptions.\n    //\n    // This is a function rather than a literal array because for an app,\n    // we need to know the file extensions registered by the plugins in\n    // order to compute the sources list, so we have to wait until build\n    // time (after we have loaded any plugins, including local plugins in\n    // this package) to compute this.\n    this.getFiles = getFiles;\n\n    // Object whose keys are relative paths of local node_modules\n    // directories in this package or application, for the given\n    // architecture. Does not include the .npm/package/node_modules\n    // directory installed by Npm.depends. Should be populated when\n    // getFiles is called.\n    this.localNodeModulesDirs = Object.create(null);\n\n    // Symbols that this architecture should export. List of symbols (as\n    // strings).\n    this.declaredExports = declaredExports;\n\n    // Files and directories that we want to monitor for changes in\n    // development mode, as a watch.WatchSet. In the latest refactoring of\n    // the code, this does not include source files or directories, but\n    // only control files such as package.js and .meteor/packages, since\n    // the rest are not determined until compile time.\n    this.watchSet = watchSet;\n  }\n}\n"]}