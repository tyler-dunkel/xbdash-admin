{"version":3,"sources":["/tools/isobuild/builder.js"],"names":["WatchSet","readAndWatchFile","sha1","files","NpmDiscards","Profile","optimisticReadFile","optimisticReaddir","optimisticLStat","ENABLE_IN_PLACE_BUILDER_REPLACEMENT","process","platform","env","METEOR_DISABLE_BUILDER_IN_PLACE","Builder","outputPath","previousBuilder","usedAsFile","previousUsedAsFile","writtenHashes","previousWrittenHashes","nonce","Math","floor","random","buildPath","pathJoin","pathDirname","pathBasename","resetBuildPath","Error","exists","rm_recursive","mkdir_p","watchSet","_ensureDirectory","relPath","parts","pathNormalize","split","pathSep","length","pop","partsSoFar","forEach","push","part","partial","join","needToMkdir","unlink","mkdir","_sanitize","isDirectory","partsOut","i","shouldBeFile","mustBeUnique","match","replace","ext","suffix","candidate","write","data","file","hash","sanitize","executable","symlink","slice","getData","Buffer","pathResolve","absPath","symlinkWithOverwrite","atomicallyRewriteFile","mode","writeJson","JSON","stringify","reserve","directory","soFar","shouldBeDirectory","generateFilename","writeToGeneratedFilename","writeOptions","generated","copyDirectory","from","to","ignore","specificFiles","npmDiscards","directoryFilter","absPathTo","specificPaths","f","walk","absFrom","relTo","absTo","thisAbsFrom","item","thisRelTo","fileStatus","itemForMatch","some","pattern","shouldDiscard","isSymbolicLink","readlink","writeFile","enter","methods","subBuilder","relPathWithSep","method","args","ret","substr","passThroughMethods","complete","removed","paths","Object","keys","path","hasOwnProperty","anotherPath","startsWith","renameDirAlmostAtomically","abort","getWatchSet","options","rname","rpath","rename","e","code","source","target","stat","slowBuilderMethods","prototype"],"mappings":"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","file":"tools/isobuild/builder.js.map","sourcesContent":["import {WatchSet, readAndWatchFile, sha1} from '../fs/watch.js';\nimport files from '../fs/files.js';\nimport NpmDiscards from './npm-discards.js';\nimport {Profile} from '../tool-env/profile.js';\nimport {\n  optimisticReadFile,\n  optimisticReaddir,\n  optimisticLStat,\n} from \"../fs/optimistic.js\";\n\n// Builder is in charge of writing \"bundles\" to disk, which are\n// directory trees such as site archives, programs, and packages.  In\n// addition to writing data to files, it can copy or link in existing\n// files and directories (keeping track of them in a WatchSet in order\n// to trigger rebuilds appropriately).\n//\n// By default, Builder constructs the entire output directory from\n// scratch under a temporary name, and then moves it into place.\n// For efficient rebuilds, Builder can be given a `previousBuilder`,\n// in which case it will write files into the existing output directory\n// instead.\n//\n// On Windows (or when METEOR_DISABLE_BUILDER_IN_PLACE is set), Builder\n// always creates a new output directory under a temporary name rather than\n// using the old directory.  The reason is that we don't want rebuilding to\n// interfere with the running app, and we rely on the fact that on OS X and\n// Linux, if the process has opened a file for reading, it retains the file\n// by its inode, not path, so it is safe to write a new file to the same path\n// (or delete the file).\n//\n// Separate from that, Builder has a strategy of writing files under a temporary\n// name and then renaming them.  This is to achieve an \"atomic\" write, meaning\n// the server doesn't see a partially-written file that appears truncated.\n//\n// On Windows we copy files instead of symlinking them (see comments inline).\n\n\n// Whether to support writing files into the same directory as a previous\n// Builder on rebuild (rather than creating a new build directory and\n// moving it into place).\nconst ENABLE_IN_PLACE_BUILDER_REPLACEMENT =\n  (process.platform !== 'win32') &&\n  ! process.env.METEOR_DISABLE_BUILDER_IN_PLACE;\n\n\n// Options:\n//  - outputPath: Required. Path to the directory that will hold the\n//    bundle when building is complete. It should not exist (unless\n//    previousBuilder is passed). Its parents will be created if necessary.\n// - previousBuilder: Optional. An in-memory instance of Builder left\n// from the previous iteration. It is assumed that the previous builder\n// has completed its job successfully and its files are stored on the\n// file system in the exact layout as described in its usedAsFile data\n// structure; and the hashes of the contents correspond to the\n// writtenHashes data strcture.\nexport default class Builder {\n  constructor({outputPath, previousBuilder}) {\n    this.outputPath = outputPath;\n\n    // Paths already written to. Map from canonicalized relPath (no\n    // trailing slash) to true for a file, or false for a directory.\n    this.usedAsFile = { '': false, '.': false };\n    this.previousUsedAsFile = {};\n\n    this.writtenHashes = {};\n    this.previousWrittenHashes = {};\n\n    // foo/bar => foo/.build1234.bar\n    // Should we include a random number? The advantage is that multiple\n    // builds can run in parallel. The disadvantage is that stale build\n    // files hang around forever. For now, go with the former.\n    const nonce = Math.floor(Math.random() * 999999);\n    this.buildPath = files.pathJoin(files.pathDirname(this.outputPath),\n                                    '.build' + nonce + \".\" +\n                                    files.pathBasename(this.outputPath));\n\n    let resetBuildPath = true;\n\n    // If we have a previous builder and we are allowed to re-use it,\n    // let's keep all the older files on the file-system and replace\n    // only outdated ones + write the new files in the same path\n    if (previousBuilder && ENABLE_IN_PLACE_BUILDER_REPLACEMENT) {\n      if (previousBuilder.outputPath !== outputPath) {\n        throw new Error(\n          `previousBuilder option can only be set to a builder with the same output path.\nPrevious builder: ${previousBuilder.outputPath}, this builder: ${outputPath}`\n        );\n      }\n\n      if (files.exists(previousBuilder.outputPath)) {\n        // write files in-place in the output directory of the previous builder\n        this.buildPath = previousBuilder.outputPath;\n\n        this.previousWrittenHashes = previousBuilder.writtenHashes;\n        this.previousUsedAsFile = previousBuilder.usedAsFile;\n\n        resetBuildPath = false;\n      } else {\n        resetBuildPath = true;\n      }\n    }\n\n    // Build the output from scratch\n    if (resetBuildPath) {\n      files.rm_recursive(this.buildPath);\n      files.mkdir_p(this.buildPath, 0o755);\n    }\n\n    this.watchSet = new WatchSet();\n\n    // XXX cleaner error handling. don't make the humans read an\n    // exception (and, make suitable for use in automated systems)\n  }\n\n  // Like mkdir_p, but records in self.usedAsFile that we have created\n  // the directories, and takes a path relative to the bundle\n  // root. Throws an exception on failure.\n  _ensureDirectory(relPath) {\n    const parts = files.pathNormalize(relPath).split(files.pathSep);\n    if (parts.length > 1 && parts[parts.length - 1] === '') {\n      // remove trailing slash\n      parts.pop();\n    }\n\n    const partsSoFar = [];\n    parts.forEach(part => {\n      partsSoFar.push(part);\n      const partial = partsSoFar.join(files.pathSep);\n      if (! (partial in this.usedAsFile)) {\n        let needToMkdir = true;\n        if (partial in this.previousUsedAsFile) {\n          if (this.previousUsedAsFile[partial]) {\n            // was previously used as file, delete it, create a directory\n            files.unlink(partial);\n          } else {\n            // is already a directory\n            needToMkdir = false;\n          }\n        }\n\n        if (needToMkdir) {\n          // It's new -- create it\n          files.mkdir(files.pathJoin(this.buildPath, partial), 0o755);\n        }\n        this.usedAsFile[partial] = false;\n      } else if (this.usedAsFile[partial]) {\n        // Already exists and is a file. Oops.\n        throw new Error(`tried to make ${relPath} a directory but ${partial} is already a file`);\n      } else {\n        // Already exists and is a directory\n      }\n    });\n  }\n\n  // isDirectory defaults to false\n  _sanitize(relPath, isDirectory) {\n    const parts = relPath.split(files.pathSep);\n    const partsOut = [];\n    for (let i = 0; i < parts.length; i++) {\n      let part = parts[i];\n      const shouldBeFile = (i === parts.length - 1) && ! isDirectory;\n      const mustBeUnique = (i === parts.length - 1);\n\n      // Basic sanitization\n      if (part.match(/^\\.+$/)) {\n        throw new Error(`Path contains forbidden segment '${part}'`);\n      }\n\n      part = part.replace(/[^a-zA-Z0-9._\\:-]/g, '');\n\n      // If at last component, pull extension (if any) off of part\n      let ext = '';\n      if (shouldBeFile) {\n        const split = part.split('.');\n        if (split.length > 1) {\n          ext = \".\" + split.pop();\n        }\n        part = split.join('.');\n      }\n\n      // Make sure it's sufficiently unique\n      let suffix = '';\n      while (true) {\n        const candidate = files.pathJoin(partsOut.join(files.pathSep), part + suffix + ext);\n        if (candidate.length) {\n          // If we've never heard of this, then it's unique enough.\n          if (!(candidate in this.usedAsFile)) {\n            break;\n          }\n          // If we want this bit to be a directory, and we don't need it to be\n          // unique (ie, it isn't the very last bit), and it's currently a\n          // directory, then that's OK.\n          if (!(mustBeUnique || this.usedAsFile[candidate])) {\n            break;\n          }\n          // OK, either we want it to be unique and it already exists; or it is\n          // currently a file (and we want it to be either a different file or a\n          // directory).  Try a new suffix.\n        }\n\n        suffix++; // first increment will do '' -> 1\n      }\n\n      partsOut.push(part + suffix + ext);\n    }\n\n    return partsOut.join(files.pathSep);\n  }\n\n  // Write either a buffer or the contents of a file to `relPath` (a\n  // path to a file relative to the bundle root), creating it (and any\n  // enclosing directories) if it doesn't exist yet. Exactly one of\n  // `data` and or `file` must be passed.\n  //\n  // Options:\n  // - data: a Buffer to write to relPath. Overrides `file`.\n  // - file: a filename to write to relPath, as a string.\n  // - sanitize: if true, then all components of the path are stripped\n  //   of any potentially troubling characters, an exception is thrown\n  //   if any path segments consist entirely of dots (eg, '..'), and\n  //   if there is a file in the bundle with the same relPath, then\n  //   the path is changed by adding a numeric suffix.\n  // - hash: a sha1 string used to determine if the contents of the\n  //   new file written is not cached.\n  // - executable: if true, mark the file as executable.\n  // - symlink: if set to a string, create a symlink to its value\n  //\n  // Returns the final canonicalize relPath that was written to.\n  //\n  // If `file` is used then it will be added to the builder's WatchSet.\n  write(relPath, {data, file, hash, sanitize, executable, symlink}) {\n    // Ensure no trailing slash\n    if (relPath.slice(-1) === files.pathSep) {\n      relPath = relPath.slice(0, -1);\n    }\n\n    // In sanitize mode, ensure path does not contain segments like\n    // '..', does not contain forbidden characters, and is unique.\n    if (sanitize) {\n      relPath = this._sanitize(relPath);\n    }\n\n    let getData = null;\n    if (data) {\n      if (! (data instanceof Buffer)) {\n        throw new Error(\"data must be a Buffer\");\n      }\n      if (file) {\n        throw new Error(\"May only pass one of data and file, not both\");\n      }\n      getData = () => data;\n    } else if (file) {\n      // postpone reading the file into memory\n      getData = () => readAndWatchFile(this.watchSet, files.pathResolve(file));\n    } else if (! symlink) {\n      throw new Error('Builder can not write without either data or a file path or a symlink path: ' + relPath);\n    }\n\n    this._ensureDirectory(files.pathDirname(relPath));\n    const absPath = files.pathJoin(this.buildPath, relPath);\n\n    if (symlink) {\n      symlinkWithOverwrite(symlink, absPath);\n    } else {\n      hash = hash || sha1(getData());\n\n      if (this.previousWrittenHashes[relPath] !== hash) {\n        // Builder is used to create build products, which should be read-only;\n        // users shouldn't be manually editing automatically generated files and\n        // expecting the results to \"stick\".\n        atomicallyRewriteFile(absPath, getData(), {\n          mode: executable ? 0o555 : 0o444\n        });\n      }\n\n      this.writtenHashes[relPath] = hash;\n    }\n    this.usedAsFile[relPath] = true;\n\n    return relPath;\n  }\n\n  // Serialize `data` as JSON and write it to `relPath` (a path to a\n  // file relative to the bundle root), creating parent directories as\n  // necessary. Throw an exception if the file already exists.\n  writeJson(relPath, data) {\n    // Ensure no trailing slash\n    if (relPath.slice(-1) === files.pathSep) {\n      relPath = relPath.slice(0, -1);\n    }\n\n    this._ensureDirectory(files.pathDirname(relPath));\n    const absPath = files.pathJoin(this.buildPath, relPath);\n\n    atomicallyRewriteFile(\n      absPath,\n      new Buffer(JSON.stringify(data, null, 2), 'utf8'),\n      {mode: 0o444});\n\n    this.usedAsFile[relPath] = true;\n  }\n\n  // Add relPath to the list of \"already taken\" paths in the\n  // bundle. This will cause write, when in sanitize mode, to never\n  // pick this filename (and will prevent files that from being\n  // written that would conflict with paths that we are expecting to\n  // be directories). Calling this twice on the same relPath will\n  // given an exception.\n  //\n  // Returns the *current* (temporary!) path to where the file or directory\n  // lives. This is so you could use non-builder code to write into a reserved\n  // directory.\n  //\n  // options:\n  // - directory: set to true to reserve this relPath to be a\n  //   directory rather than a file.\n  reserve(relPath, {directory} = {}) {\n    // Ensure no trailing slash\n    if (relPath.slice(-1) === files.pathSep) {\n      relPath = relPath.slice(0, -1);\n    }\n\n    const parts = relPath.split(files.pathSep);\n    const partsSoFar = [];\n    for (let i = 0; i < parts.length; i ++) {\n      const part = parts[i];\n      partsSoFar.push(part);\n      const soFar = partsSoFar.join(files.pathSep);\n      if (this.usedAsFile[soFar]) {\n        throw new Error(\"Path reservation conflict: \" + relPath);\n      }\n\n      const shouldBeDirectory = (i < parts.length - 1) || directory;\n      if (shouldBeDirectory) {\n        if (! (soFar in this.usedAsFile)) {\n          let needToMkdir = true;\n          if (soFar in this.previousUsedAsFile) {\n            if (this.previousUsedAsFile[soFar]) {\n              files.unlink(soFar);\n            } else {\n              needToMkdir = false;\n            }\n          }\n          if (needToMkdir) {\n            files.mkdir(files.pathJoin(this.buildPath, soFar), 0o755);\n          }\n          this.usedAsFile[soFar] = false;\n        }\n      } else {\n        this.usedAsFile[soFar] = true;\n      }\n    }\n\n    // Return the path we reserved.\n    return files.pathJoin(this.buildPath, relPath);\n  }\n\n  // Generate and reserve a unique name for a file based on `relPath`,\n  // and return it. If `relPath` is available (there is no file with\n  // that name currently existing or reserved, it doesn't contain\n  // forbidden characters, a prefix of it is not already in use as a\n  // file rather than a directory) then the return value will be\n  // `relPath`. Otherwise relPath will be modified to get the return\n  // value, say by adding a numeric suffix to some path components\n  // (preserving the file extension however) and deleting forbidden\n  // characters. Throws an exception if relPath contains any segments\n  // that are all dots (eg, '..').\n  //\n  // options:\n  //\n  // - directory: generate (and reserve) a name for a directory,\n  //   rather than a file.\n  generateFilename(relPath, {directory} = {}) {\n    relPath = this._sanitize(relPath, directory);\n    this.reserve(relPath, { directory });\n    return relPath;\n  }\n\n  // Convenience wrapper around generateFilename and write.\n  //\n  // (Note that in the object returned by builder.enter, this method\n  // is patched through directly rather than rewriting its inputs and\n  // outputs. This is only valid because it does nothing with its inputs\n  // and outputs other than send pass them to other methods.)\n  writeToGeneratedFilename(relPath, writeOptions) {\n    const generated = this.generateFilename(relPath);\n    this.write(generated, writeOptions);\n    return generated;\n  }\n\n  // Recursively copy a directory and all of its contents into the\n  // bundle. But if the symlink option was passed to the Builder\n  // constructor, then make a symlink instead, if possible.\n  //\n  // Unlike with files.cp_r, if a symlink is found, it is copied as a symlink.\n  //\n  // This does NOT add anything to the WatchSet.\n  //\n  // Options:\n  // - from: source path on local disk to copy from\n  // - to: relative path to a directory in the bundle that will\n  //   receive the files\n  // - ignore: array of regexps of filenames (that is, basenames) to\n  //   ignore (they may still be visible in the output bundle if\n  //   symlinks are being used).  Like with WatchSets, they match against\n  //   entries that end with a slash if it's a directory.\n  // - specificFiles: just copy these paths (specified as relative to 'to').\n  // - symlink: true if the directory should be symlinked instead of copying\n  copyDirectory({\n    from, to,\n    ignore,\n    specificFiles,\n    symlink,\n    npmDiscards,\n    directoryFilter,\n  }) {\n    if (to.slice(-1) === files.pathSep) {\n      to = to.slice(0, -1);\n    }\n\n    const absPathTo = files.pathJoin(this.buildPath, to);\n\n    if (symlink) {\n      if (specificFiles) {\n        throw new Error(\"can't copy only specific paths with a single symlink\");\n      }\n\n      if (this.usedAsFile[to]) {\n        throw new Error(\"tried to copy a directory onto \" + to +\n                        \" but it is is already a file\");\n      }\n    }\n\n    ignore = ignore || [];\n    let specificPaths = null;\n    if (specificFiles) {\n      specificPaths = {};\n      specificFiles.forEach(f => {\n        while (f !== '.') {\n          specificPaths[files.pathJoin(to, f)] = true;\n          f = files.pathDirname(f);\n        }\n      });\n    }\n\n    let walk = (absFrom, relTo) => {\n      if (symlink && ! (relTo in this.usedAsFile)) {\n        this._ensureDirectory(files.pathDirname(relTo));\n        const absTo = files.pathResolve(this.buildPath, relTo);\n        symlinkWithOverwrite(absFrom, absTo);\n        return;\n      }\n\n      this._ensureDirectory(relTo);\n\n      optimisticReaddir(absFrom).forEach(item => {\n        const thisAbsFrom = files.pathResolve(absFrom, item);\n        const thisRelTo = files.pathJoin(relTo, item);\n\n        if (specificPaths && !(thisRelTo in specificPaths)) {\n          return;\n        }\n\n        const fileStatus = optimisticLStat(thisAbsFrom);\n\n        let itemForMatch = item;\n        const isDirectory = fileStatus.isDirectory();\n        if (isDirectory) {\n          itemForMatch += '/';\n        }\n\n        // skip excluded files\n        if (ignore.some(pattern => itemForMatch.match(pattern))) {\n          return;\n        }\n\n        if (npmDiscards instanceof NpmDiscards &&\n            npmDiscards.shouldDiscard(thisAbsFrom, isDirectory)) {\n          return;\n        }\n\n        if (isDirectory) {\n          if (typeof directoryFilter !== \"function\" ||\n              directoryFilter(thisAbsFrom)) {\n            walk(thisAbsFrom, thisRelTo);\n          }\n\n        } else if (fileStatus.isSymbolicLink()) {\n          symlinkWithOverwrite(\n            files.readlink(thisAbsFrom),\n            files.pathResolve(this.buildPath, thisRelTo)\n          );\n\n          // A symlink counts as a file, as far as \"can you put something under\n          // it\" goes.\n          this.usedAsFile[thisRelTo] = true;\n\n        } else {\n          // XXX can't really optimize this copying without reading\n          // the file into memory to calculate the hash.\n          files.writeFile(\n            files.pathResolve(this.buildPath, thisRelTo),\n            optimisticReadFile(thisAbsFrom),\n            { mode: fileStatus.mode },\n          );\n\n          this.usedAsFile[thisRelTo] = true;\n        }\n      });\n    };\n\n    walk(from, to);\n  }\n\n  // Returns a new Builder-compatible object that works just like a\n  // Builder, but interprets all paths relative to 'relPath', a path\n  // relative to the bundle root which should not start with a '/'.\n  //\n  // The sub-builder returned does not have all Builder methods (for\n  // example, complete() wouldn't make sense) and you should not rely\n  // on it being instanceof Builder.\n  enter(relPath) {\n    const methods = [\"write\", \"writeJson\", \"reserve\", \"generateFilename\",\n                   \"copyDirectory\", \"enter\"];\n    const subBuilder = {};\n    const relPathWithSep = relPath + files.pathSep;\n\n    methods.forEach(method => {\n      subBuilder[method] = (...args) => {\n        if (method !== \"copyDirectory\") {\n          // Normal method (relPath as first argument)\n          args[0] = files.pathJoin(relPath, args[0]);\n        } else {\n          // with copyDirectory the path we have to fix up is inside\n          // an options hash\n          args[0].to = files.pathJoin(relPath, args[0].to);\n        }\n\n        let ret = this[method](...args);\n\n        if (method === \"generateFilename\") {\n          // fix up the returned path to be relative to the\n          // sub-bundle, not the parent bundle\n          if (ret.substr(0, 1) === '/') {\n            ret = ret.substr(1);\n          }\n          if (ret.substr(0, relPathWithSep.length) !== relPathWithSep) {\n            throw new Error(\"generateFilename returned path outside of \" +\n                            \"sub-bundle?\");\n          }\n          ret = ret.substr(relPathWithSep.length);\n        }\n\n        return ret;\n      };\n    });\n\n    // Methods that don't have to fix up arguments or return values, because\n    // they are implemented purely in terms of other methods which do.\n    const passThroughMethods = [\"writeToGeneratedFilename\"];\n    passThroughMethods.forEach(method => {\n      subBuilder[method] = this[method];\n    });\n\n    return subBuilder;\n  }\n\n  // Move the completed bundle into its final location (outputPath)\n  complete() {\n    if (this.previousUsedAsFile) {\n      // delete files and folders left-over from previous runs and not\n      // re-used in this run\n      const removed = {};\n      const paths = Object.keys(this.previousUsedAsFile);\n      paths.forEach((path) => {\n        // if the same path was re-used, leave it\n        if (this.usedAsFile.hasOwnProperty(path)) { return; }\n\n        // otherwise, remove it as it is no longer needed\n\n        // skip if already deleted\n        if (removed.hasOwnProperty(path)) { return; }\n\n        const absPath = files.pathJoin(this.buildPath, path);\n        if (this.previousUsedAsFile[path]) {\n          // file\n          files.unlink(absPath);\n          removed[path] = true;\n        } else {\n          // directory\n          files.rm_recursive(absPath);\n\n          // mark all sub-paths as removed, too\n          paths.forEach((anotherPath) => {\n            if (anotherPath.startsWith(path + '/')) {\n              removed[anotherPath] = true;\n            }\n          });\n        }\n      });\n    }\n\n    // XXX Alternatively, we could just keep buildPath around, and make\n    // outputPath be a symlink pointing to it. This doesn't work for the NPM use\n    // case of renameDirAlmostAtomically since that one is constructing files to\n    // be checked in to version control, but here we could get away with it.\n    if (this.buildPath !== this.outputPath) {\n      files.renameDirAlmostAtomically(this.buildPath, this.outputPath);\n    }\n  }\n\n  // Delete the partially-completed bundle. Do not disturb outputPath.\n  abort() {\n    files.rm_recursive(this.buildPath);\n  }\n\n  // Returns a WatchSet representing all files that were read from disk by the\n  // builder.\n  getWatchSet() {\n    return this.watchSet;\n  }\n}\n\nfunction atomicallyRewriteFile(path, data, options) {\n  // create a different file with a random name and then rename over atomically\n  const rname = '.builder-tmp-file.' + Math.floor(Math.random() * 999999);\n  const rpath = files.pathJoin(files.pathDirname(path), rname);\n  files.writeFile(rpath, data, options);\n  try {\n    files.rename(rpath, path);\n  } catch (e) {\n    if (e.code === 'EISDIR') {\n      // replacing a directory with a file; this is rare (so it can\n      // be a slow path) but can legitimately happen if e.g. a developer\n      // puts a file where there used to be a directory in their app.\n      files.rm_recursive(path);\n      files.rename(rpath, path);\n    } else {\n      throw e;\n    }\n  }\n}\n\n// create a symlink, overwriting the target link, file, or directory\n// if it exists\nfunction symlinkWithOverwrite(source, target) {\n  const args = [source, target];\n\n  if (process.platform === \"win32\") {\n    if (! files.stat(source).isDirectory()) {\n      throw new Error(\"symlink source must be a directory: \" + source);\n    }\n\n    args[2] = \"junction\";\n  }\n\n  try {\n    files.symlink(...args);\n  } catch (e) {\n    if (e.code === 'EEXIST') {\n      // overwrite existing link, file, or directory\n      files.rm_recursive(target);\n      files.symlink(...args);\n    } else {\n      throw e;\n    }\n  }\n}\n\n// Wrap slow methods into Profiler calls\nconst slowBuilderMethods = [\n  '_ensureDirectory', 'write', 'enter', 'copyDirectory', 'enter', 'complete'\n];\n\nslowBuilderMethods.forEach(method => {\n  Builder.prototype[method] =\n    Profile(`Builder#${method}`, Builder.prototype[method]);\n});\n"]}