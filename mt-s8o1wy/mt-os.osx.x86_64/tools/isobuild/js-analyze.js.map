{"version":3,"sources":["/tools/isobuild/js-analyze.js"],"names":["parse","analyze","analyzeScope","LRU","hasOwn","Object","prototype","hasOwnProperty","AST_CACHE","max","Math","pow","length","ast","loc","end","line","tryToParse","source","hash","has","get","e","$ParseError","set","dependencyKeywordPattern","findImportedModuleIdentifiers","identifiers","possibleIndexes","match","lastIndex","exec","push","index","walk","node","left","right","requireIsBound","Array","isArray","i","len","isNode","start","isFunctionWithParameter","id","getRequiredModuleId","addIdentifier","getImportedModuleId","keys","key","type","entry","call","possiblySpurious","value","isIdWithName","name","params","some","param","callee","args","arguments","argc","arg","isStringLiteral","object","property","globalsCache","globals","sum","forEach","findAssignedGlobals","scopeManager","ecmaVersion","sourceType","ignoreEval","nodejsScope","program","programScope","acquire","assignedGlobals","implicit","variables","variable","identifier","writeExpr"],"mappings":"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","file":"tools/isobuild/js-analyze.js.map","sourcesContent":["import { parse } from 'meteor-babel';\nimport { analyze as analyzeScope } from 'escope';\nimport LRU from \"lru-cache\";\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nvar AST_CACHE = new LRU({\n  max: Math.pow(2, 12),\n  length(ast) {\n    return ast.loc.end.line;\n  }\n});\n\n// Like babel.parse, but annotates any thrown error with $ParseError = true.\nfunction tryToParse(source, hash) {\n  if (hash && AST_CACHE.has(hash)) {\n    return AST_CACHE.get(hash);\n  }\n\n  let ast;\n\n  try {\n    ast = parse(source);\n  } catch (e) {\n    if (typeof e.loc === 'object') {\n      e.$ParseError = true;\n    }\n    throw e;\n  }\n\n  if (hash) {\n    AST_CACHE.set(hash, ast);\n  }\n\n  return ast;\n}\n\nvar dependencyKeywordPattern = /\\b(require|import|export)\\b/g;\n\n/**\n * The `findImportedModuleIdentifiers` function takes a string of module\n * source code and returns a map from imported module identifiers to AST\n * nodes. The keys of this map are used in ./import-scanner.js to traverse\n * the module dependency graph. The AST nodes are generally ignored.\n *\n * The implementation uses a regular expression to scan quickly for\n * possible locations of certain tokens (`require`, `import`, `export`),\n * then uses that location information to steer the AST traversal, so that\n * it visits only subtrees that contain interesting tokens, saving a lot\n * of time by ignoring the rest of the AST. The AST traversal determines\n * if the tokens were actually what we thought they were (a `require`\n * function call, or an `import` or `export` statement).\n */\nexport function findImportedModuleIdentifiers(source, hash) {\n  const identifiers = {};\n  const possibleIndexes = [];\n  let match;\n\n  dependencyKeywordPattern.lastIndex = 0;\n  while ((match = dependencyKeywordPattern.exec(source))) {\n    possibleIndexes.push(match.index);\n  }\n\n  if (!possibleIndexes.length) {\n    return {};\n  }\n\n  const ast = tryToParse(source, hash);\n\n  function walk(node, left, right, requireIsBound) {\n    if (left >= right) {\n      // The window of possible indexes is empty, so we can ignore\n      // the entire subtree rooted at this node.\n    } else if (Array.isArray(node)) {\n      for (var i = 0, len = node.length; i < len; ++i) {\n        walk(node[i], left, right, requireIsBound);\n      }\n    } else if (isNode(node)) {\n      const start = node.start;\n      const end = node.end;\n\n      // Narrow the left-right window to exclude possible indexes\n      // that fall outside of the current node.\n      while (left < right && possibleIndexes[left] < start) ++left;\n      while (left < right && end < possibleIndexes[right - 1]) --right;\n\n      if (left < right) {\n        if (! requireIsBound &&\n            isFunctionWithParameter(node, \"require\")) {\n          requireIsBound = true;\n        }\n\n        let id = getRequiredModuleId(node);\n        if (typeof id === \"string\") {\n          return addIdentifier(id, \"require\", requireIsBound);\n        }\n\n        id = getImportedModuleId(node);\n        if (typeof id === \"string\") {\n          return addIdentifier(id, \"import\", requireIsBound);\n        }\n\n        // Continue traversing the children of this node.\n        for (const key of Object.keys(node)) {\n          switch (key) {\n          case \"type\":\n          case \"loc\":\n          case \"start\":\n          case \"end\":\n            // Ignore common keys that are never nodes.\n            continue;\n          }\n\n          walk(node[key], left, right, requireIsBound);\n        }\n      }\n    }\n  }\n\n  function addIdentifier(id, type, requireIsBound) {\n    const entry = hasOwn.call(identifiers, id)\n      ? identifiers[id]\n      : identifiers[id] = { possiblySpurious: true };\n\n    if (type === \"require\") {\n      // If the identifier comes from a require call, but require is not a\n      // free variable, then this dependency might be spurious.\n      entry.possiblySpurious =\n        entry.possiblySpurious && requireIsBound;\n    } else {\n      // The import keyword can't be shadowed, so any dependencies\n      // registered by import statements should be trusted absolutely.\n      entry.possiblySpurious = false;\n    }\n  }\n\n  walk(ast, 0, possibleIndexes.length, false);\n\n  return identifiers;\n}\n\nfunction isNode(value) {\n  return value\n    && typeof value === \"object\"\n    && typeof value.type === \"string\"\n    && typeof value.start === \"number\"\n    && typeof value.end === \"number\";\n}\n\nfunction isIdWithName(node, name) {\n  return node &&\n    node.type === \"Identifier\" &&\n    node.name === name;\n}\n\nfunction isFunctionWithParameter(node, name) {\n  if (node.type === \"FunctionExpression\" ||\n      node.type === \"FunctionDeclaration\" ||\n      node.type === \"ArrowFunctionExpression\") {\n    return node.params.some(param => isIdWithName(param, name));\n  }\n}\n\nfunction getRequiredModuleId(node) {\n  if (node.type === \"CallExpression\" &&\n      isIdWithName(node.callee, \"require\")) {\n    const args = node.arguments;\n    const argc = args.length;\n    if (argc > 0) {\n      const arg = args[0];\n      if (isStringLiteral(arg)) {\n        return arg.value;\n      }\n    }\n  }\n}\n\nfunction isStringLiteral(node) {\n  return node && (\n    node.type === \"StringLiteral\" ||\n    (node.type === \"Literal\" &&\n     typeof node.value === \"string\"));\n}\n\nfunction getImportedModuleId(node) {\n  if (node.type === \"CallExpression\" &&\n      node.callee.type === \"MemberExpression\" &&\n      isIdWithName(node.callee.object, \"module\") &&\n      isIdWithName(node.callee.property, \"import\")) {\n    const args = node.arguments;\n    const argc = args.length;\n    if (argc > 0) {\n      const arg = args[0];\n      if (isStringLiteral(arg)) {\n        return arg.value;\n      }\n    }\n  }\n\n  if (node.type === \"ImportDeclaration\" ||\n      node.type === \"ExportAllDeclaration\" ||\n      node.type === \"ExportNamedDeclaration\") {\n    // The .source of an ImportDeclaration or Export{Named,All}Declaration\n    // is always a string-valued Literal node, if not null.\n    if (isNode(node.source)) {\n      return node.source.value;\n    }\n  }\n}\n\n// Analyze the JavaScript source code `source` and return a dictionary of all\n// globals which are assigned to in the package. The values in the dictionary\n// are all `true`.\n//\n// This is intended for use in detecting package-scope variables in Meteor\n// packages, where the linker needs to add a \"var\" statement to prevent them\n// from staying as globals.\n//\n// It only cares about assignments to variables; an assignment to a field on an\n// object (`Foo.Bar = true`) neither causes `Foo` nor `Foo.Bar` to be returned.\nconst globalsCache = new LRU({\n  max: Math.pow(2, 12),\n  length(globals) {\n    let sum = 0;\n    Object.keys(globals).forEach(name => sum += name.length);\n    return sum;\n  }\n});\n\nexport function findAssignedGlobals(source, hash) {\n  if (hash && globalsCache.has(hash)) {\n    return globalsCache.get(hash);\n  }\n\n  const ast = tryToParse(source, hash);\n\n  // We have to pass ignoreEval; otherwise, the existence of a direct eval call\n  // causes escope to not bother to resolve references in the eval's scope.\n  // This is because an eval can pull references inward:\n  //\n  //   function outer() {\n  //     var i = 42;\n  //     function inner() {\n  //       eval('var i = 0');\n  //       i;  // 0, not 42\n  //     }\n  //   }\n  //\n  // But it can't pull references outward, so for our purposes it is safe to\n  // ignore.\n  const scopeManager = analyzeScope(ast, {\n    ecmaVersion: 6,\n    sourceType: \"module\",\n    ignoreEval: true,\n    // Ensures we don't treat top-level var declarations as globals.\n    nodejsScope: true,\n  });\n\n  const program = ast.type === \"File\" ? ast.program : ast;\n  const programScope = scopeManager.acquire(program);\n  const assignedGlobals = {};\n\n  // Passing {sourceType: \"module\"} to analyzeScope leaves this list\n  // strangely empty, but {sourceType: \"script\"} forbids ImportDeclaration\n  // nodes (because they are only legal in modules.\n  programScope.implicit.variables.forEach(variable => {\n    assignedGlobals[variable.name] = true;\n  });\n\n  // Fortunately, even with {sourceType: \"module\"}, the .implicit.left\n  // array still has all the information we need, as long as we ignore\n  // global variable references that are not assignments.\n  programScope.implicit.left.forEach(entry => {\n    if (entry.identifier &&\n        entry.identifier.type === \"Identifier\" &&\n        // Only consider identifers that are assigned a value.\n        entry.writeExpr) {\n      assignedGlobals[entry.identifier.name] = true;\n    }\n  });\n\n  if (hash) {\n    globalsCache.set(hash, assignedGlobals);\n  }\n\n  return assignedGlobals;\n}\n"]}