{"version":3,"sources":["/tools/isobuild/import-scanner.js"],"names":["assert","inspect","Script","isString","isEmpty","has","keys","each","map","omit","sha1","matches","archMatches","findImportedModuleIdentifiers","cssToCommonJS","buildmessage","LRU","Profile","SourceNode","SourceMapConsumer","pathJoin","pathRelative","pathNormalize","pathDirname","pathBasename","pathExtname","pathIsAbsolute","convertToOSPath","convertToPosixPath","optimisticReadFile","optimisticStatOrNull","optimisticHashOrNull","Resolver","fakeFileStat","isFile","isDirectory","defaultExtensionHandlers","dataString","replace","JSON","stringify","parse","hash","scriptParseCache","Object","create","canBeParsedAsPlainJS","result","e","IMPORT_SCANNER_CACHE","max","length","ids","total","info","id","ImportScanner","name","bundleArch","extensions","sourceRoot","nodeModulesPaths","watchSet","scanner","ok","absPathToOutputIndex","allMissingNodeModules","outputFiles","resolver","getOrCreate","caller","targetArch","statOrNull","absPath","file","_getFile","toLowerCase","_addFile","old","emptyStub","push","addInputFiles","files","forEach","_checkSourceAndTargetPaths","sourcePath","dotExt","type","data","toString","Buffer","imported","lazy","installPath","_getInstallPath","_combineFiles","_getSourcePath","targetPath","absSourcePath","absTargetPath","sourceFile","servePath","deps","relativeId","indexOf","charAt","oldFile","newFile","checkProperty","Error","getChunk","consumer","sourceMap","node","fromStringWithSourceMap","toStringWithSourceMap","combinedDataString","code","combinedSourceMap","toJSON","mappings","scanImports","_scanFile","addNodeModules","identifiers","Array","isArray","newlyMissing","newlyAdded","previousAllMissingNodeModules","key","getOutputFiles","options","filter","relPath","startsWith","_joinAndStat","path","_findImportedModuleIdentifiers","get","set","_resolve","resolved","resolve","_onMissing","packageJsonMap","pkg","_addPkgJsonToOutput","$ParseError","error","message","line","loc","column","absImportedPath","depFile","alreadyScanned","_readModule","isWeb","_readFile","contents","addFile","ext","charCodeAt","slice","_getNodeModulesInstallPath","_getSourceRootInstallPath","some","relPathWithinNodeModules","dirs","_splitPath","isApp","bundlingForWeb","topLevelDir","dir","partsInReverse","reverse","absParentPath","parentFile","isNative","stubId","getNativeStubId","possiblySpurious","packageName","parentPath","missing","missingNodeModules","pkgJsonPath","value","join","relPkgJsonPath","pkgFile","prototype","funcName"],"mappings":"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","file":"tools/isobuild/import-scanner.js.map","sourcesContent":["import assert from \"assert\";\nimport {inspect} from \"util\";\nimport {Script} from \"vm\";\nimport {\n  isString, isEmpty, has, keys, each, map, omit,\n} from \"underscore\";\nimport {sha1} from \"../fs/watch.js\";\nimport {matches as archMatches} from \"../utils/archinfo.js\";\nimport {findImportedModuleIdentifiers} from \"./js-analyze.js\";\nimport {cssToCommonJS} from \"./css-modules.js\";\nimport buildmessage from \"../utils/buildmessage.js\";\nimport LRU from \"lru-cache\";\nimport {Profile} from \"../tool-env/profile.js\";\nimport {SourceNode, SourceMapConsumer} from \"source-map\";\nimport {\n  pathJoin,\n  pathRelative,\n  pathNormalize,\n  pathDirname,\n  pathBasename,\n  pathExtname,\n  pathIsAbsolute,\n  convertToOSPath,\n  convertToPosixPath,\n} from \"../fs/files.js\";\n\nimport {\n  optimisticReadFile,\n  optimisticStatOrNull,\n  optimisticHashOrNull,\n} from \"../fs/optimistic.js\";\n\nimport Resolver from \"./resolver.js\";\n\nconst fakeFileStat = {\n  isFile() {\n    return true;\n  },\n\n  isDirectory() {\n    return false;\n  }\n};\n\n// Default handlers for well-known file extensions.\n// Note that these function expect strings, not Buffer objects.\nconst defaultExtensionHandlers = {\n  \".js\"(dataString) {\n    // Strip any #! line from the beginning of the file.\n    return dataString.replace(/^#![^\\n]*/, \"\");\n  },\n\n  \".json\"(dataString) {\n    return \"module.exports = \" +\n      JSON.stringify(JSON.parse(dataString), null, 2) +\n      \";\\n\";\n  },\n\n  \".css\"(dataString, hash) {\n    return cssToCommonJS(dataString, hash);\n  }\n};\n\n// This is just a map from hashes to booleans, so it doesn't need full LRU\n// eviction logic.\nconst scriptParseCache = Object.create(null);\n\nfunction canBeParsedAsPlainJS(dataString, hash) {\n  if (hash && has(scriptParseCache, hash)) {\n    return scriptParseCache[hash];\n  }\n\n  try {\n    var result = !! new Script(dataString);\n  } catch (e) {\n    result = false;\n  }\n\n  if (hash) {\n    scriptParseCache[hash] = result;\n  }\n\n  return result;\n}\n\n// Map from SHA (which is already calculated, so free for us)\n// to the results of calling findImportedModuleIdentifiers.\n// Each entry is an array of strings, and this is a case where\n// the computation is expensive but the output is very small.\n// The cache can be global because findImportedModuleIdentifiers\n// is a pure function, and that way it applies across instances\n// of ImportScanner (which do not persist across builds).\nconst IMPORT_SCANNER_CACHE = new LRU({\n  max: 1024*1024,\n  length(ids) {\n    let total = 40; // size of key\n    each(ids, (info, id) => { total += id.length; });\n    return total;\n  }\n});\n\nexport default class ImportScanner {\n  constructor({\n    name,\n    bundleArch,\n    extensions,\n    sourceRoot,\n    nodeModulesPaths = [],\n    watchSet,\n  }) {\n    const scanner = this;\n    assert.ok(isString(sourceRoot));\n\n    this.name = name;\n    this.bundleArch = bundleArch;\n    this.sourceRoot = sourceRoot;\n    this.nodeModulesPaths = nodeModulesPaths;\n    this.watchSet = watchSet;\n    this.absPathToOutputIndex = Object.create(null);\n    this.allMissingNodeModules = Object.create(null);\n    this.outputFiles = [];\n\n    this.resolver = Resolver.getOrCreate({\n      caller: \"ImportScanner#constructor\",\n\n      sourceRoot,\n      targetArch: bundleArch,\n      extensions,\n      nodeModulesPaths,\n\n      statOrNull(absPath) {\n        const file = scanner._getFile(absPath);\n        if (file) {\n          return fakeFileStat;\n        }\n\n        return optimisticStatOrNull(absPath);\n      }\n    });\n  }\n\n  _getFile(absPath) {\n    absPath = absPath.toLowerCase();\n    if (has(this.absPathToOutputIndex, absPath)) {\n      return this.outputFiles[this.absPathToOutputIndex[absPath]];\n    }\n  }\n\n  _addFile(absPath, file) {\n    absPath = absPath.toLowerCase();\n    const old = this.absPathToOutputIndex[absPath];\n\n    if (old) {\n      // If the old file is just an empty stub, let the new file take\n      // precedence over it.\n      if (old.emptyStub === true) {\n        return this.absPathToOutputIndex[absPath] = file;\n      }\n\n      // If the new file is just an empty stub, pretend the _addFile\n      // succeeded by returning the old file, so that we won't try to call\n      // _combineFiles needlessly.\n      if (file.emptyStub === true) {\n        return old;\n      }\n\n    } else {\n      this.absPathToOutputIndex[absPath] =\n        this.outputFiles.push(file) - 1;\n\n      return file;\n    }\n  }\n\n  addInputFiles(files) {\n    files.forEach(file => {\n      this._checkSourceAndTargetPaths(file);\n\n      // Note: this absolute path may not necessarily exist on the file\n      // system, but any import statements or require calls in file.data\n      // will be interpreted relative to this path, so it needs to be\n      // something plausible. #6411 #6383\n      const absPath = pathJoin(this.sourceRoot, file.sourcePath);\n\n      const dotExt = \".\" + file.type;\n      const dataString = file.data.toString(\"utf8\");\n      file.dataString = defaultExtensionHandlers[dotExt](\n        dataString, file.hash);\n\n      if (! (file.data instanceof Buffer) ||\n          file.dataString !== dataString) {\n        file.data = new Buffer(file.dataString, \"utf8\");\n      }\n\n      // Files that are not eagerly evaluated (lazy) will only be included\n      // in the bundle if they are actually imported. Files that are\n      // eagerly evaluated are effectively \"imported\" as entry points.\n      file.imported = ! file.lazy;\n\n      file.installPath = file.installPath || this._getInstallPath(absPath);\n\n      if (! this._addFile(absPath, file)) {\n        // Collisions can happen if a compiler plugin calls addJavaScript\n        // multiple times with the same sourcePath. #6422\n        this._combineFiles(this._getFile(absPath), file);\n      }\n    });\n\n    return this;\n  }\n\n  // Make sure file.sourcePath is defined, and handle the possibility that\n  // file.targetPath differs from file.sourcePath.\n  _checkSourceAndTargetPaths(file) {\n    file.sourcePath = this._getSourcePath(file);\n\n    if (! isString(file.targetPath)) {\n      return;\n    }\n\n    file.targetPath = pathNormalize(pathJoin(\".\", file.targetPath));\n\n    if (file.targetPath !== file.sourcePath) {\n      const absSourcePath = pathJoin(this.sourceRoot, file.sourcePath);\n      const absTargetPath = pathJoin(this.sourceRoot, file.targetPath);\n\n      // If file.targetPath differs from file.sourcePath, generate a new\n      // file object with that .sourcePath that imports the original file.\n      // This allows either the .sourcePath or the .targetPath to be used\n      // when importing the original file, and also allows multiple files\n      // to have the same .sourcePath but different .targetPaths.\n      let sourceFile = this._getFile(absSourcePath);\n      if (! sourceFile) {\n        const installPath = this._getInstallPath(absSourcePath);\n        sourceFile = this._addFile(absSourcePath, {\n          type: file.type,\n          sourcePath: file.sourcePath,\n          servePath: installPath,\n          installPath,\n          dataString: \"\",\n          deps: {},\n          lazy: true,\n        });\n      }\n\n      // Make sure the original file gets installed at the target path\n      // instead of the source path.\n      file.installPath = this._getInstallPath(absTargetPath);\n      file.sourcePath = file.targetPath;\n\n      let relativeId = convertToPosixPath(pathRelative(\n        pathDirname(absSourcePath),\n        absTargetPath\n      ));\n\n      // If the result of pathRelative does not already start with a \".\"\n      // or a \"/\", prepend a \"./\" to make it a valid relative identifier\n      // according to CommonJS syntax.\n      if (\"./\".indexOf(relativeId.charAt(0)) < 0) {\n        relativeId = \"./\" + relativeId;\n      }\n\n      // Set the contents of the source module to import the target\n      // module(s). Note that module.exports will be set to the exports of\n      // the last target module. This is not perfect, but (1) it's better\n      // than trying to merge exports, (2) it does the right thing when\n      // there's only one target module, (3) the plugin author can easily\n      // control which file comes last, and (4) it's always possible to\n      // import the target modules individually.\n      sourceFile.dataString += \"module.exports = require(\" +\n        JSON.stringify(relativeId) + \");\\n\";\n      sourceFile.data = new Buffer(sourceFile.dataString, \"utf8\");\n      sourceFile.hash = sha1(sourceFile.data);\n      sourceFile.deps[relativeId] = {};\n    }\n  }\n\n  // Concatenate the contents of oldFile and newFile, combining source\n  // maps and updating all other properties appropriately. Once this\n  // combination is done, oldFile should be kept and newFile discarded.\n  _combineFiles(oldFile, newFile) {\n    function checkProperty(name) {\n      if (has(oldFile, name)) {\n        if (! has(newFile, name)) {\n          newFile[name] = oldFile[name];\n        }\n      } else if (has(newFile, name)) {\n        oldFile[name] = newFile[name];\n      }\n\n      if (oldFile[name] !== newFile[name]) {\n        throw new Error(\n          \"Attempting to combine different files:\\n\" +\n            inspect(omit(oldFile, \"dataString\")) + \"\\n\" +\n            inspect(omit(newFile, \"dataString\")) + \"\\n\"\n        );\n      }\n    }\n\n    // Since we're concatenating the files together, they must be either\n    // both lazy or both eager. Same for bareness.\n    checkProperty(\"lazy\");\n    checkProperty(\"bare\");\n\n    function getChunk(file) {\n      const consumer = file.sourceMap &&\n        new SourceMapConsumer(file.sourceMap);\n      const node = consumer &&\n        SourceNode.fromStringWithSourceMap(file.dataString, consumer);\n      return node || file.dataString;\n    }\n\n    const {\n      code: combinedDataString,\n      map: combinedSourceMap,\n    } = new SourceNode(null, null, null, [\n      getChunk(oldFile),\n      \"\\n\\n\",\n      getChunk(newFile)\n    ]).toStringWithSourceMap({\n      file: oldFile.servePath || newFile.servePath\n    });\n\n    oldFile.dataString = combinedDataString;\n    oldFile.data = new Buffer(oldFile.dataString, \"utf8\");\n    oldFile.hash = sha1(oldFile.data);\n    oldFile.imported = oldFile.imported || newFile.imported;\n    oldFile.sourceMap = combinedSourceMap.toJSON();\n    if (! oldFile.sourceMap.mappings) {\n      oldFile.sourceMap = null;\n    }\n  }\n\n  scanImports() {\n    this.outputFiles.forEach(file => {\n      if (! file.lazy || file.imported) {\n        this._scanFile(file);\n      }\n    });\n\n    return this;\n  }\n\n  addNodeModules(identifiers) {\n    assert.ok(identifiers);\n    assert.ok(typeof identifiers === \"object\");\n    assert.ok(! Array.isArray(identifiers));\n\n    const newlyMissing = Object.create(null);\n    const newlyAdded = Object.create(null);\n\n    if (! isEmpty(identifiers)) {\n      const previousAllMissingNodeModules = this.allMissingNodeModules;\n      this.allMissingNodeModules = newlyMissing;\n\n      try {\n        this._scanFile({\n          sourcePath: \"fake.js\",\n          // By specifying the .deps property of this fake file ahead of\n          // time, we can avoid calling findImportedModuleIdentifiers in the\n          // _scanFile method.\n          deps: identifiers,\n        });\n\n      } finally {\n        this.allMissingNodeModules = previousAllMissingNodeModules;\n\n        each(identifiers, (info, id) => {\n          if (! has(newlyMissing, id)) {\n            newlyAdded[id] = info;\n          }\n        });\n\n        // Remove previously seen missing module identifiers from\n        // newlyMissing and merge the new identifiers back into\n        // this.allMissingNodeModules.\n        each(keys(newlyMissing), key => {\n          if (has(previousAllMissingNodeModules, key)) {\n            delete newlyMissing[key];\n          } else {\n            previousAllMissingNodeModules[key] =\n              newlyMissing[key];\n          }\n        });\n      }\n    }\n\n    return {\n      newlyAdded,\n      newlyMissing,\n    };\n  }\n\n  getOutputFiles(options) {\n    // Return all installable output files that are either eager or\n    // imported by another module.\n    return this.outputFiles.filter(file => {\n      return file.installPath && (! file.lazy || file.imported);\n    });\n  }\n\n  _getSourcePath(file) {\n    let sourcePath = file.sourcePath;\n    if (sourcePath) {\n      if (pathIsAbsolute(sourcePath)) {\n        try {\n          var relPath = pathRelative(this.sourceRoot, sourcePath);\n\n        } finally {\n          if (! relPath || relPath.startsWith(\"..\")) {\n            if (this.resolver._joinAndStat(this.sourceRoot, sourcePath)) {\n              // If sourcePath exists as a path relative to this.sourceRoot,\n              // strip away the leading / that made it look absolute.\n              return pathNormalize(pathJoin(\".\", sourcePath));\n            }\n\n            if (relPath) {\n              throw new Error(\"sourcePath outside sourceRoot: \" + sourcePath);\n            }\n\n            // If pathRelative threw an exception above, and we were not\n            // able to handle the problem, it will continue propagating\n            // from this finally block.\n          }\n        }\n\n        sourcePath = relPath;\n      }\n\n    } else if (file.servePath) {\n      sourcePath = convertToOSPath(file.servePath.replace(/^\\//, \"\"));\n\n    } else if (file.path) {\n      sourcePath = file.path;\n    }\n\n    return pathNormalize(pathJoin(\".\", sourcePath));\n  }\n\n  _findImportedModuleIdentifiers(file) {\n    if (IMPORT_SCANNER_CACHE.has(file.hash)) {\n      return IMPORT_SCANNER_CACHE.get(file.hash);\n    }\n\n    const result = findImportedModuleIdentifiers(\n      file.dataString,\n      file.hash,\n    );\n\n    // there should always be file.hash, but better safe than sorry\n    if (file.hash) {\n      IMPORT_SCANNER_CACHE.set(file.hash, result);\n    }\n\n    return result;\n  }\n\n  _resolve(id, absPath) {\n    const resolved = this.resolver.resolve(id, absPath);\n\n    if (resolved === \"missing\") {\n      return this._onMissing(id, absPath);\n    }\n\n    if (resolved && resolved.packageJsonMap) {\n      each(resolved.packageJsonMap, (pkg, path) => {\n        this._addPkgJsonToOutput(path, pkg);\n      });\n    }\n\n    return resolved;\n  }\n\n  _scanFile(file) {\n    const absPath = pathJoin(this.sourceRoot, file.sourcePath);\n\n    try {\n      file.deps = file.deps || this._findImportedModuleIdentifiers(file);\n    } catch (e) {\n      if (e.$ParseError) {\n        buildmessage.error(e.message, {\n          file: file.sourcePath,\n          line: e.loc.line,\n          column: e.loc.column,\n        });\n        return;\n      }\n      throw e;\n    }\n\n    each(file.deps, (info, id) => {\n      const resolved = this._resolve(id, absPath);\n      if (! resolved) {\n        return;\n      }\n\n      const absImportedPath = resolved.path;\n\n      let depFile = this._getFile(absImportedPath);\n      if (depFile) {\n        // Avoid scanning files that we've scanned before, but mark them\n        // as imported so we know to include them in the bundle if they\n        // are lazy. Eager files and files that we have imported before do\n        // not need to be scanned again. Lazy files that we have not\n        // imported before still need to be scanned, however.\n        const alreadyScanned = ! depFile.lazy || depFile.imported;\n\n        // Whether the file is eager or lazy, mark it as imported. For\n        // lazy files, this makes the difference between being included in\n        // or omitted from the bundle. For eager files, this just ensures\n        // we won't scan them again.\n        depFile.imported = true;\n\n        if (! alreadyScanned) {\n          if (depFile.error) {\n            // Since this file is lazy, it might never have been imported,\n            // so any errors reported to InputFile#error were saved but\n            // not reported at compilation time. Now that we know the file\n            // has been imported, it's time to report those errors.\n            buildmessage.error(depFile.error.message,\n                               depFile.error.info);\n          } else {\n            this._scanFile(depFile);\n          }\n        }\n\n        return;\n      }\n\n      const installPath = this._getInstallPath(absImportedPath);\n      if (! installPath) {\n        // The given path cannot be installed on this architecture.\n        return;\n      }\n\n      // If the module is not readable, _readModule may return\n      // null. Otherwise it will return an object with .data, .dataString,\n      // and .hash properties.\n      depFile = this._readModule(absImportedPath);\n      if (! depFile) {\n        return;\n      }\n\n      depFile.type = \"js\"; // TODO Is this correct?\n      depFile.sourcePath = pathRelative(this.sourceRoot, absImportedPath);\n      depFile.installPath = installPath;\n      depFile.servePath = installPath;\n      depFile.lazy = true;\n      depFile.imported = true;\n\n      // Append this file to the output array and record its index.\n      this._addFile(absImportedPath, depFile);\n\n      if (! this.isWeb() &&\n          depFile.installPath.startsWith(\"node_modules/\")) {\n        // On the server, modules in node_modules directories will be\n        // handled natively by Node, so we don't need to build a\n        // meteorInstall-style bundle beyond the entry-point module.\n        return;\n      }\n\n      this._scanFile(depFile);\n    });\n  }\n\n  isWeb() {\n    return archMatches(this.bundleArch, \"web\");\n  }\n\n  _readFile(absPath) {\n    const contents = optimisticReadFile(absPath);\n    const hash = optimisticHashOrNull(absPath);\n\n    this.watchSet.addFile(absPath, hash);\n\n    return {\n      data: contents,\n      dataString: contents.toString(\"utf8\"),\n      hash\n    };\n  }\n\n  _readModule(absPath) {\n    let ext = pathExtname(absPath).toLowerCase();\n\n    if (ext === \".node\") {\n      const dataString = \"throw new Error(\" + JSON.stringify(\n        this.isWeb()\n          ? \"cannot load native .node modules on the client\"\n          : \"module.useNode() must succeed for native .node modules\"\n      ) + \");\\n\";\n\n      const data = new Buffer(dataString, \"utf8\");\n      const hash = sha1(data);\n\n      return { data, dataString, hash };\n    }\n\n    try {\n      var info = this._readFile(absPath);\n    } catch (e) {\n      if (e.code !== \"ENOENT\") throw e;\n      return null;\n    }\n\n    const dataString = info.dataString;\n\n    // Same logic/comment as stripBOM in node/lib/module.js:\n    // Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n    // because the buffer-to-string conversion in `fs.readFileSync()`\n    // translates it to FEFF, the UTF-16 BOM.\n    if (info.dataString.charCodeAt(0) === 0xfeff) {\n      info.dataString = info.dataString.slice(1);\n    }\n\n    if (! has(defaultExtensionHandlers, ext)) {\n      if (canBeParsedAsPlainJS(dataString)) {\n        ext = \".js\";\n      } else {\n        return null;\n      }\n    }\n\n    info.dataString = defaultExtensionHandlers[ext](\n      info.dataString,\n      info.hash,\n    );\n\n    if (info.dataString !== dataString) {\n      info.data = new Buffer(info.dataString, \"utf8\");\n    }\n\n    return info;\n  }\n\n  // Returns a relative path indicating where to install the given file\n  // via meteorInstall. May return undefined if the file should not be\n  // installed on the current architecture.\n  _getInstallPath(absPath) {\n    let path =\n      this._getNodeModulesInstallPath(absPath) ||\n      this._getSourceRootInstallPath(absPath);\n\n    if (! path) {\n      return;\n    }\n\n    if (this.name) {\n      // If we're bundling a package, prefix path with\n      // node_modules/<package name>/.\n      path = pathJoin(\"node_modules\", \"meteor\", this.name, path);\n    }\n\n    // Install paths should always be delimited by /.\n    return convertToPosixPath(path);\n  }\n\n  _getNodeModulesInstallPath(absPath) {\n    let installPath;\n\n    this.nodeModulesPaths.some(path => {\n      const relPathWithinNodeModules = pathRelative(path, absPath);\n\n      if (relPathWithinNodeModules.startsWith(\"..\")) {\n        // absPath is not a subdirectory of path.\n        return;\n      }\n\n      // Install the module into the local node_modules directory within\n      // this app or package.\n      return installPath = pathJoin(\n        \"node_modules\",\n        relPathWithinNodeModules\n      );\n    });\n\n    return installPath;\n  }\n\n  _getSourceRootInstallPath(absPath) {\n    const installPath = pathRelative(this.sourceRoot, absPath);\n\n    if (installPath.startsWith(\"..\")) {\n      // absPath is not a subdirectory of this.sourceRoot.\n      return;\n    }\n\n    const dirs = this._splitPath(pathDirname(installPath));\n    const isApp = ! this.name;\n    const bundlingForWeb = this.isWeb();\n\n    const topLevelDir = dirs[0];\n    if (topLevelDir === \"private\" ||\n        topLevelDir === \"packages\" ||\n        topLevelDir === \"programs\" ||\n        topLevelDir === \"cordova-build-override\") {\n      // Don't load anything from these special top-level directories\n      return;\n    }\n\n    for (let dir of dirs) {\n      if (dir.charAt(0) === \".\") {\n        // Files/directories whose names start with a dot are never loaded\n        return;\n      }\n\n      if (isApp) {\n        if (bundlingForWeb) {\n          if (dir === \"server\") {\n            // If we're bundling an app for a client architecture, any files\n            // contained by a server-only directory that is not contained by\n            // a node_modules directory must be ignored.\n            return;\n          }\n        } else if (dir === \"client\") {\n          // If we're bundling an app for a server architecture, any files\n          // contained by a client-only directory that is not contained by\n          // a node_modules directory must be ignored.\n          return;\n        }\n      }\n\n      if (dir === \"node_modules\") {\n        // Accept any file within a node_modules directory.\n        return installPath;\n      }\n    }\n\n    return installPath;\n  }\n\n  _splitPath(path) {\n    const partsInReverse = [];\n    for (let dir; (dir = pathDirname(path)) !== path; path = dir) {\n      partsInReverse.push(pathBasename(path));\n    }\n    return partsInReverse.reverse();\n  }\n\n  // Called by this.resolver when a module identifier cannot be resolved.\n  _onMissing(id, absParentPath) {\n    const isApp = ! this.name;\n    const parentFile = this._getFile(absParentPath);\n\n    if (isApp &&\n        Resolver.isNative(id) &&\n        this.isWeb()) {\n      // To ensure the native module can be evaluated at runtime, register\n      // a dependency on meteor-node-stubs/deps/<id>.js.\n      const stubId = Resolver.getNativeStubId(id);\n      if (isString(stubId) && stubId !== id) {\n        if (parentFile &&\n            parentFile.deps) {\n          parentFile.deps[stubId] = parentFile.deps[id];\n        }\n        return this._resolve(stubId, absParentPath);\n      }\n    }\n\n    const possiblySpurious =\n      parentFile &&\n      parentFile.deps &&\n      has(parentFile.deps, id) &&\n      parentFile.deps[id].possiblySpurious;\n\n    const info = {\n      packageName: this.name,\n      parentPath: absParentPath,\n      bundleArch: this.bundleArch,\n      possiblySpurious,\n    };\n\n    // If the imported identifier is neither absolute nor relative, but\n    // top-level, then it might be satisfied by a package installed in\n    // the top-level node_modules directory, and we should record the\n    // missing dependency so that we can include it in the app bundle.\n    if (parentFile) {\n      const missing =\n        parentFile.missingNodeModules ||\n        Object.create(null);\n      missing[id] = info;\n      parentFile.missingNodeModules = missing;\n    }\n\n    if (! has(this.allMissingNodeModules, id) ||\n        ! info.possiblySpurious) {\n      // Allow any non-spurious identifier to replace an existing\n      // possibly spurious identifier.\n      this.allMissingNodeModules[id] = info;\n    }\n  }\n\n  _addPkgJsonToOutput(pkgJsonPath, pkg) {\n    if (! this._getFile(pkgJsonPath)) {\n      const data = new Buffer(map(pkg, (value, key) => {\n        return `exports.${key} = ${JSON.stringify(value)};\\n`;\n      }).join(\"\"));\n\n      const relPkgJsonPath = pathRelative(this.sourceRoot, pkgJsonPath);\n\n      const pkgFile = {\n        type: \"js\", // We represent the JSON module with JS.\n        data,\n        deps: {}, // Avoid accidentally re-scanning this file.\n        sourcePath: relPkgJsonPath,\n        installPath: this._getInstallPath(pkgJsonPath),\n        servePath: relPkgJsonPath,\n        hash: sha1(data),\n        lazy: true,\n        imported: true,\n      };\n\n      this._addFile(pkgJsonPath, pkgFile);\n\n      const hash = optimisticHashOrNull(pkgJsonPath);\n      if (hash) {\n        this.watchSet.addFile(pkgJsonPath, hash);\n      }\n    }\n  }\n}\n\neach([\"_readFile\", \"_findImportedModuleIdentifiers\",\n      \"_getInstallPath\"], funcName => {\n  ImportScanner.prototype[funcName] = Profile(\n    `ImportScanner#${funcName}`, ImportScanner.prototype[funcName]);\n});\n"]}