{"version":3,"sources":["/tools/fs/safe-watcher.js"],"names":["watchLibrary","Profile","statOrNull","pathDirname","convertToOSPath","convertToStandardPath","watchFile","unwatchFile","WATCHER_ENABLED","process","env","METEOR_WATCH_FORCE_POLLING","platform","DEFAULT_POLLING_INTERVAL","METEOR_WATCH_POLLING_INTERVAL_MS","NO_WATCHER_POLLING_INTERVAL","WATCHER_CLEANUP_DELAY_MS","watchers","Object","create","watchersByIno","Map","acquireWatcher","absPath","callback","entry","startNewWatcher","rewatch","callbacks","add","stat","ino","has","get","safeUnwatch","watcher","close","lastWatcherEventTime","Date","Set","watcherCleanupTimer","pollingInterval","fire","event","forEach","cb","call","watchWrapper","watchLibraryWatch","watchFileWrapper","persistent","interval","args","newStat","oldStat","mtime","release","size","clearTimeout","setTimeout","set","closeAllWatchers","keys","watch","e","maybeSuggestRaisingWatchLimit","suggestedRaisingWatchLimit","error","constants","require","archinfo","errno","ENOSPC","matches","host","Console","isHeadless","arrowWarn","url"],"mappings":"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","file":"tools/fs/safe-watcher.js.map","sourcesContent":["import * as watchLibrary from \"pathwatcher\";\nimport { Profile } from \"../tool-env/profile.js\";\nimport {\n  statOrNull,\n  pathDirname,\n  convertToOSPath,\n  convertToStandardPath,\n  watchFile,\n  unwatchFile,\n} from \"./files.js\";\n\n// Set METEOR_WATCH_FORCE_POLLING environment variable to a truthy value to\n// force the use of files.watchFile instead of watchLibrary.watch.\n// Enabled on Mac and Linux and disabled on Windows by default.\nvar WATCHER_ENABLED = ! process.env.METEOR_WATCH_FORCE_POLLING;\nif (process.platform === \"win32\") {\n  WATCHER_ENABLED = false;\n}\n\nvar DEFAULT_POLLING_INTERVAL =\n  ~~process.env.METEOR_WATCH_POLLING_INTERVAL_MS || 5000;\n\nvar NO_WATCHER_POLLING_INTERVAL =\n  ~~process.env.METEOR_WATCH_POLLING_INTERVAL_MS || 500;\n\n// This may seems like a long time to wait before actually closing the\n// file watchers, but it's to our advantage if they survive restarts.\nconst WATCHER_CLEANUP_DELAY_MS = 30000;\n\nconst watchers = Object.create(null);\n\n// Pathwatcher complains (using console.error, ugh) if you try to watch\n// two files with the same stat.ino number but different paths, so we have\n// to deduplicate files by ino.\nconst watchersByIno = new Map;\n\nfunction acquireWatcher(absPath, callback) {\n  const entry = watchers[absPath] || (\n    watchers[absPath] = startNewWatcher(absPath));\n\n  // Watches successfully established in the past may have become invalid\n  // because the watched file was deleted or renamed, so we need to make\n  // sure we're still watching every time we call safeWatcher.watch.\n  entry.rewatch();\n\n  // The size of the entry.callbacks Set also serves as a reference count\n  // for this watcher.\n  entry.callbacks.add(callback);\n\n  return entry;\n}\n\nfunction startNewWatcher(absPath) {\n  const stat = statOrNull(absPath);\n  const ino = stat && stat.ino;\n  if (ino > 0 && watchersByIno.has(ino)) {\n    return watchersByIno.get(ino);\n  }\n\n  function safeUnwatch() {\n    if (watcher) {\n      watcher.close();\n      watcher = null;\n      if (ino > 0) {\n        watchersByIno.delete(ino);\n      }\n    }\n  }\n\n  let lastWatcherEventTime = +new Date;\n  const callbacks = new Set;\n  let watcherCleanupTimer = null;\n  let watcher;\n  let pollingInterval;\n\n  function fire(event) {\n    if (event !== \"change\") {\n      // When we receive a \"delete\" or \"rename\" event, the watcher is\n      // probably not going to generate any more notifications for this\n      // file, so we close and nullify the watcher to ensure that\n      // entry.rewatch() will attempt to reestablish the watcher the next\n      // time we call safeWatcher.watch.\n      safeUnwatch();\n\n      // Make sure we don't throttle the watchFile callback after a\n      // \"delete\" or \"rename\" event, since it is now our only reliable\n      // source of file change notifications.\n      lastWatcherEventTime = 0;\n    }\n\n    callbacks.forEach(cb => cb.call(this, event));\n  }\n\n  function watchWrapper(event) {\n    lastWatcherEventTime = +new Date;\n    fire.call(this, event);\n\n    // It's tempting to call unwatchFile(absPath, watchFileWrapper) here,\n    // but previous watcher success is no guarantee of future watcher\n    // reliability. For example, watchLibrary.watch works just fine when file\n    // changes originate from within a Vagrant VM, but changes to shared\n    // files made outside the VM are invisible to watcher, so our only\n    // hope of catching them is to continue polling.\n  }\n\n  function rewatch() {\n    if (watcher) {\n      // Already watching; nothing to do.\n      return;\n    }\n\n    watcher = watchLibraryWatch(absPath, watchWrapper);\n\n    pollingInterval = watcher\n      ? DEFAULT_POLLING_INTERVAL\n      : NO_WATCHER_POLLING_INTERVAL;\n\n    // This is a no-op if we're not watching the file.\n    unwatchFile(absPath, watchFileWrapper);\n\n    // We use files.watchFile in addition to watcher.watch as a fail-safe\n    // to detect file changes even on network file systems.  However\n    // (unless the user disabled watcher or this watcher call failed), we\n    // use a relatively long default polling interval of 5000ms to save\n    // CPU cycles.\n    watchFile(absPath, {\n      persistent: false,\n      interval: pollingInterval,\n    }, watchFileWrapper);\n  }\n\n  function watchFileWrapper(...args) {\n    const [newStat, oldStat] = args;\n\n    if (newStat.ino === 0 &&\n        oldStat.ino === 0 &&\n        +newStat.mtime === +oldStat.mtime) {\n      // Node calls the watchFile listener once with bogus identical stat\n      // objects, which should not trigger a file change event.\n      return;\n    }\n\n    // If a watcher event fired in the last polling interval, ignore\n    // this event.\n    if (new Date - lastWatcherEventTime > pollingInterval) {\n      fire.call(this, \"change\");\n    }\n  }\n\n  rewatch();\n\n  const entry = {\n    callbacks,\n    rewatch,\n\n    release(callback) {\n      if (! watchers[absPath]) {\n        return;\n      }\n\n      callbacks.delete(callback);\n      if (callbacks.size > 0) {\n        return;\n      }\n\n      // Once there are no more callbacks in the Set, close both watchers\n      // and nullify the shared data.\n      clearTimeout(watcherCleanupTimer);\n      watcherCleanupTimer = setTimeout(() => {\n        if (callbacks.size > 0) {\n          // If another callback was added while the timer was pending, we\n          // can avoid tearing anything down.\n          return;\n        }\n        entry.close();\n      }, WATCHER_CLEANUP_DELAY_MS);\n    },\n\n    close() {\n      if (watchers[absPath] !== entry) return;\n      watchers[absPath] = null;\n\n      if (watcherCleanupTimer) {\n        clearTimeout(watcherCleanupTimer);\n        watcherCleanupTimer = null;\n      }\n\n      safeUnwatch();\n\n      unwatchFile(absPath, watchFileWrapper);\n    }\n  };\n\n  if (ino > 0) {\n    watchersByIno.set(ino, entry);\n  }\n\n  return entry;\n}\n\nexport function closeAllWatchers() {\n  Object.keys(watchers).forEach(absPath => {\n    const entry = watchers[absPath];\n    if (entry) {\n      entry.close();\n    }\n  });\n}\n\nfunction watchLibraryWatch(absPath, callback) {\n  if (WATCHER_ENABLED) {\n    try {\n      return watchLibrary.watch(convertToOSPath(absPath), callback);\n    } catch (e) {\n      maybeSuggestRaisingWatchLimit(e);\n      // ... ignore the error.  We'll still have watchFile, which is good\n      // enough.\n    }\n  }\n\n  return null;\n}\n\nlet suggestedRaisingWatchLimit = false;\n\nfunction maybeSuggestRaisingWatchLimit(error) {\n  var constants = require('constants');\n  var archinfo = require('../utils/archinfo.js');\n  if (! suggestedRaisingWatchLimit &&\n      // Note: the not-super-documented require('constants') maps from\n      // strings to SYSTEM errno values. System errno values aren't the same\n      // as the numbers used internally by libuv! Once we're upgraded\n      // to Node 0.12, we'll have the system errno as a string (on 'code'),\n      // but the support for that wasn't in Node 0.10's uv.\n      // See our PR https://github.com/atom/node-pathwatcher/pull/53\n      // (and make sure to read the final commit message, not the original\n      // proposed PR, which had a slightly different interface).\n      error.errno === constants.ENOSPC &&\n      // The only suggestion we currently have is for Linux.\n      archinfo.matches(archinfo.host(), 'os.linux')) {\n    suggestedRaisingWatchLimit = true;\n    var Console = require('../console/console.js').Console;\n    if (! Console.isHeadless()) {\n      Console.arrowWarn(\n        \"It looks like a simple tweak to your system's configuration will \" +\n          \"make many tools (including this Meteor command) more efficient. \" +\n          \"To learn more, see \" +\n          Console.url(\"https://github.com/meteor/meteor/wiki/File-Change-Watcher-Efficiency\"));\n    }\n  }\n}\n\nexport const watch = Profile(\n  \"safeWatcher.watch\",\n  (absPath, callback) => {\n    const entry = acquireWatcher(absPath, callback);\n    return {\n      close() {\n        entry.release(callback);\n      }\n    };\n  }\n);\n"]}