{"version":3,"sources":["/tools/fs/watch.js"],"names":["files","_","safeWatcher","createHash","coalesce","Profile","optimisticStatOrNull","optimisticReaddir","optimisticHashOrNull","WatchSet","self","alwaysFire","directories","addFile","filePath","hash","has","addDirectory","absPath","include","exclude","names","unsortedContents","contents","isEmpty","clone","sort","push","merge","other","each","name","dir","ret","toJSON","reToJSON","r","options","ignoreCase","multiline","global","$regex","source","$options","map","d","fromJSON","json","set","reFromJSON","j","RegExp","readFile","e","code","sha1","update","digest","readDirectory","readdir","contentsWithSlashes","entry","stat","statOrNull","pathJoin","isDirectory","filtered","filter","indexOf","some","re","test","Watcher","watchSet","Error","onChange","stopped","justCheckOnce","_justCheckOnce","watches","_fire","_startFileWatches","_checkDirectories","_fireIfFileChanged","oldHash","undefined","newHash","_fireIfDirectoryChanged","info","newContents","isEqual","_watchFileOrDirectory","watcher","lastStat","_mustNotExist","onWatchEvent","_makeWatchEventCallback","watch","_mustBeAFile","parentDir","pathDirname","_updateStatForWatch","isFile","dirFiles","err","file","fullPath","wsFiles","isString","mustNotExist","mustBeAFile","stop","close","isUpToDate","time","upToDate","readAndWatchDirectory","extend","readAndWatchFileWithHash","readAndWatchFile"],"mappings":"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","file":"tools/fs/watch.js.map","sourcesContent":["import files from './files.js';\nimport _ from \"underscore\";\nimport * as safeWatcher from './safe-watcher.js';\nimport {createHash} from \"crypto\";\nimport {coalesce} from '../utils/func-utils.js';\nimport {Profile} from '../tool-env/profile.js';\n\nimport {\n  optimisticStatOrNull,\n  optimisticReaddir,\n  optimisticHashOrNull,\n} from \"./optimistic.js\";\n\n// Watch for changes to a set of files, and the first time that any of\n// the files change, call a user-provided callback. (If you want a\n// second callback, you'll need to create a second Watcher.)\n//\n// You describe the structure you want to watch in a WatchSet; you then create a\n// Watcher to watch it. Watcher does not mutate WatchSet, so you can create\n// several Watchers from the same WatchSet. WatchSet can be easily converted to\n// and from JSON for serialization.\n//\n// You can set up two kinds of watches, file and directory watches.\n//\n// In a file watch, you provide an absolute path to a file and a SHA1 (encoded\n// as hex) of the contents of that file. If the file ever changes so that its\n// contents no longer match that SHA1, the callback triggers. You can also\n// provide `null` for the SHA1, which means the file should not exist.\n//\n// In a directory watch, you provide an absolute path to a directory,\n// two lists of regular expressions specifying the entries to\n// include and exclude, a list of specific names to include (which ignores\n// the exclude regexp list) and an array of which entries to expect.\n//\n// For directory watches, the regular expressions work as follows. You provide\n// two arrays of regular expressions, an include list and an exclude list. An\n// entry in the directory matches if it matches at least one regular expression\n// in the include list, and doesn't match any regular expressions in the exclude\n// list. The string that is matched against the regular expression ends with a\n// '/' if the entry is directory. There is NO IMPLICIT RECURSION here: a\n// directory watch ONLY watches the immediate children of the directory! If you\n// want a recursive watch, you need to do the recursive walk while building the\n// WatchSet and add a bunch of separate directory watches.  In addition, you\n// can provide a list of specific names to expect; these are not filtered\n// by the exclude list.  (For example, you might want to see all \"*.js\" files\n// but ignore files starting with dots (which are often temporary files), but\n// explicitly ask for \".jshintrc\".)\n//\n// There can be multiple directory watches on the same directory. There is no\n// relationship between the files found in directory watches and the files\n// watched by file watches; they are parallel mechanisms.\n//\n// Regular expressions are checked only against individual path components (the\n// actual name of the file or the subdirectory) plus the trailing '/' for\n// directories, not against the entire path.\n//\n// You can call stop() to stop watching and tear down the\n// watcher. Calling stop() guarantees that you will not receive a\n// callback (if you have not already). Calling stop() is unnecessary\n// if you've received a callback.\n//\n// To do a \"one-shot\" (to see if any files have been modified, compared to the\n// dependencies, at a particular point in time), use the isUpToDate function.\n//\n// XXX Symlinks are currently treated transparently: we treat them as the thing\n// they point to (ie, as a directory if they point to a directory, as\n// nonexistent if they point to something nonexist, etc). Not sure if this is\n// correct.\n\nexport class WatchSet {\n  constructor() {\n    var self = this;\n\n    // Set this to true if any Watcher built on this WatchSet must immediately\n    // fire (eg, if this WatchSet was given two different sha1 for the same file).\n    self.alwaysFire = false;\n\n    // Map from the absolute path to a file, to a sha1 hash, or null if the file\n    // should not exist. A Watcher created from this set fires when the file\n    // changes from that sha, or is deleted (if non-null) or created (if null).\n    //\n    // Note that Isopack.getSourceFilesUnderSourceRoot() depends on this field\n    // existing (it's not just an internal implementation detail of watch.js).\n    self.files = {};\n\n    // Array of object with keys:\n    // - 'absPath': absolute path to a directory\n    // - 'include': array of RegExps\n    // - 'exclude': array of RegExps\n    // - 'names': array of strings\n    // - 'contents': array of strings, or null if the directory should not exist\n    //\n    // This represents the assertion that 'absPath' is a directory and that\n    // 'contents' is its immediate contents, as filtered by the regular\n    // expressions.  Entries in 'contents' are file and subdirectory names;\n    // directory names end with '/'. 'contents' is sorted. An entry is in\n    // 'contents' if its value (including the slash, for directories) matches at\n    // least one regular expression in 'include' and no regular expressions in\n    // 'exclude'... or if it is in 'names'.\n    //\n    // There is no recursion here: files contained in subdirectories never appear.\n    //\n    // A directory may have multiple entries (presumably with different\n    // include/exclude filters).\n    self.directories = [];\n  }\n\n  addFile(filePath, hash) {\n    var self = this;\n    // No need to update if this is in always-fire mode already.\n    if (self.alwaysFire) {\n      return;\n    }\n    if (_.has(self.files, filePath)) {\n      // Redundant?\n      if (self.files[filePath] === hash) {\n        return;\n      }\n      // Nope, inconsistent.\n      self.alwaysFire = true;\n      return;\n    }\n    self.files[filePath] = hash;\n  }\n\n  addDirectory({absPath, include, exclude, names, contents: unsortedContents}) {\n    var self = this;\n    if (self.alwaysFire) {\n      return;\n    }\n    if (_.isEmpty(include) && _.isEmpty(names)) {\n      return;\n    }\n    const contents = _.clone(unsortedContents);\n    if (contents) {\n      contents.sort();\n    }\n\n    self.directories.push({absPath, include, exclude, names, contents});\n  }\n\n  // Merges another WatchSet into this one. This one will now fire if either\n  // WatchSet would have fired.\n  merge(other) {\n    var self = this;\n    if (self.alwaysFire) {\n      return;\n    }\n    if (other.alwaysFire) {\n      self.alwaysFire = true;\n      return;\n    }\n   _.each(other.files, function (hash, name) {\n     self.addFile(name, hash);\n   });\n    _.each(other.directories, function (dir) {\n      // XXX this doesn't deep-clone the directory, but I think these objects\n      // are never mutated #WatchSetShallowClone\n      self.directories.push(dir);\n    });\n  }\n\n  clone() {\n    var self = this;\n    var ret = new WatchSet();\n\n    // XXX doesn't bother to deep-clone the directory info\n    // #WatchSetShallowClone\n    ret.alwaysFire = self.alwaysFire;\n    ret.files = _.clone(self.files);\n    ret.directories = _.clone(self.directories);\n    return ret;\n  }\n\n  toJSON() {\n    var self = this;\n    if (self.alwaysFire) {\n      return {alwaysFire: true};\n    }\n    var ret = {files: self.files};\n\n    var reToJSON = function (r) {\n      var options = '';\n      if (r.ignoreCase) {\n        options += 'i';\n      }\n      if (r.multiline) {\n        options += 'm';\n      }\n      if (r.global) {\n        options += 'g';\n      }\n      if (options) {\n        return {$regex: r.source, $options: options};\n      }\n      return r.source;\n    };\n\n    ret.directories = _.map(self.directories, function (d) {\n      return {\n        absPath: d.absPath,\n        include: _.map(d.include, reToJSON),\n        exclude: _.map(d.exclude, reToJSON),\n        names: d.names,\n        contents: d.contents\n      };\n    });\n\n    return ret;\n  }\n\n  static fromJSON(json) {\n    var set = new WatchSet();\n\n    if (! json) {\n      return set;\n    }\n\n    if (json.alwaysFire) {\n      set.alwaysFire = true;\n      return set;\n    }\n\n    set.files = _.clone(json.files);\n\n    var reFromJSON = function (j) {\n      if (_.has(j, '$regex')) {\n        return new RegExp(j.$regex, j.$options);\n      }\n      return new RegExp(j);\n    };\n\n    set.directories = _.map(json.directories, function (d) {\n      return {\n        absPath: d.absPath,\n        include: _.map(d.include, reFromJSON),\n        exclude: _.map(d.exclude, reFromJSON),\n        names: d.names,\n        contents: d.contents\n      };\n    });\n\n    return set;\n  }\n}\n\nexport function readFile(absPath) {\n  try {\n    return files.readFile(absPath);\n  } catch (e) {\n    // Rethrow most errors.\n    if (! e || (e.code !== 'ENOENT' && e.code !== 'EISDIR')) {\n      throw e;\n    }\n    // File does not exist (or is a directory).\n    return null;\n  }\n};\n\nexport function sha1(contents) {\n  return Profile(\"sha1\", function () {\n    var hash = createHash('sha1');\n    hash.update(contents);\n    return hash.digest('hex');\n  })();\n}\n\nexport function readDirectory({absPath, include, exclude, names}) {\n  // Read the directory.\n  try {\n    var contents = files.readdir(absPath);\n  } catch (e) {\n    // If the path is not a directory, return null; let other errors through.\n    if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) {\n      return null;\n    }\n    throw e;\n  }\n\n  // Add slashes to the end of directories.\n  var contentsWithSlashes = [];\n  _.each(contents, function (entry) {\n    // We do stat instead of lstat here, so that we treat symlinks to\n    // directories just like directories themselves.\n    const stat = files.statOrNull(files.pathJoin(absPath, entry));\n    if (! stat) {\n      // Disappeared after the readdir (or a dangling symlink)?\n      // Eh, pretend it was never there in the first place.\n      return;\n    }\n\n    if (stat.isDirectory()) {\n      entry += '/';\n    }\n\n    contentsWithSlashes.push(entry);\n  });\n\n  // Filter based on regexps.\n  var filtered = contentsWithSlashes.filter((entry) => {\n    // Is it one of the names we explicitly requested?\n    if (names && names.indexOf(entry) !== -1) {\n      return true;\n    }\n    // Is it ruled out by an exclude rule?\n    if (exclude && exclude.some(re => re.test(entry))) {\n      return false;\n    }\n    // Is it ruled in by an include rule?\n    if (include && include.some(re => re.test(entry))) {\n      return true;\n    }\n    return false;\n  });\n\n  // Sort it!\n  filtered.sort();\n  return filtered;\n}\n\n// All fields are private.\nexport class Watcher {\n  constructor(options) {\n    var self = this;\n\n    // The set to watch.\n    self.watchSet = options.watchSet;\n    if (! self.watchSet) {\n      throw new Error(\"watchSet option is required\");\n    }\n\n    // Function to call when a change is detected according to one of\n    // the above.\n    self.onChange = options.onChange;\n    if (! self.onChange) {\n      throw new Error(\"onChange option is required\");\n    }\n\n    self.stopped = false;\n    self.justCheckOnce = !! options._justCheckOnce;\n\n    self.watches = {\n      // <absolute path of watched file or directory>: {\n      //   // Null until safeWatcher.watch succeeds in watching the file.\n      //   watcher: <object returned by safeWatcher.watch> | null,\n      //   // Undefined until we stat the file for the first time, then null\n      //   // if the file is observed to be missing.\n      //   lastStat: <object returned by files.stat> | null | undefined\n      // }\n    };\n\n    // Were we given an inconsistent WatchSet? Fire now and be done with it.\n    if (self.watchSet.alwaysFire) {\n      self._fire();\n      return;\n    }\n\n    self._startFileWatches();\n    self._checkDirectories();\n  }\n\n  _fireIfFileChanged(absPath) {\n    var self = this;\n\n    if (self.stopped) {\n      return true;\n    }\n\n    var oldHash = self.watchSet.files[absPath];\n\n    if (oldHash === undefined) {\n      throw new Error(\"Checking unknown file \" + absPath);\n    }\n\n    var newHash = optimisticHashOrNull(absPath);\n\n    if (newHash === null) {\n      // File does not exist (or is a directory).\n      // Is this what we expected?\n      if (oldHash === null) {\n        return false;\n      }\n      // Nope, not what we expected.\n      self._fire();\n      return true;\n    }\n\n    // File exists! Is that what we expected?\n    if (oldHash === null) {\n      self._fire();\n      return true;\n    }\n\n    // Unchanged?\n    if (newHash === oldHash) {\n      return false;\n    }\n\n    self._fire();\n    return true;\n  }\n\n  _fireIfDirectoryChanged(info) {\n    var self = this;\n\n    if (self.stopped) {\n      return true;\n    }\n\n    var newContents = readDirectory({\n      absPath: info.absPath,\n      include: info.include,\n      exclude: info.exclude,\n      names: info.names\n    });\n\n    // If the directory has changed (including being deleted or created).\n    if (! _.isEqual(info.contents, newContents)) {\n      self._fire();\n      return true;\n    }\n\n    return false;\n  }\n\n  _startFileWatches() {\n    var self = this;\n\n    // Set up a watch for each file\n    _.each(self.watchSet.files, function (hash, absPath) {\n      if (self.stopped) {\n        return;\n      }\n\n      if (! self.justCheckOnce) {\n        self._watchFileOrDirectory(absPath);\n      }\n\n      // Check for the case where by the time we created the watch,\n      // the file had already changed from the sha we were provided.\n      self._fireIfFileChanged(absPath);\n    });\n  }\n\n  _watchFileOrDirectory(absPath) {\n    var self = this;\n\n    if (! _.has(self.watches, absPath)) {\n      self.watches[absPath] = {\n        watcher: null,\n        // Initially undefined (instead of null) to indicate we have never\n        // called files.stat on this file before.\n        lastStat: undefined\n      };\n    }\n\n    var entry = self.watches[absPath];\n    if (entry.watcher) {\n      // Already watching this path.\n      return;\n    }\n\n    if (files.statOrNull(absPath)) {\n      if (self._mustNotExist(absPath)) {\n        self._fire();\n        return;\n      }\n\n      var onWatchEvent = self._makeWatchEventCallback(absPath);\n      entry.watcher = safeWatcher.watch(absPath, onWatchEvent);\n\n      // If we successfully created the watcher, invoke the callback\n      // immediately, so that we examine this file at least once.\n      onWatchEvent();\n\n    } else {\n      if (self._mustBeAFile(absPath)) {\n        self._fire();\n        return;\n      }\n\n      var parentDir = files.pathDirname(absPath);\n      if (parentDir === absPath) {\n        throw new Error(\"Unable to watch parent directory of \" + absPath);\n      }\n\n      self._watchFileOrDirectory(parentDir);\n    }\n  }\n\n  _makeWatchEventCallback(absPath) {\n    var self = this;\n\n    // Sometimes we receive a rapid succession of change events, perhaps\n    // because several files were modified at once (e.g. by git reset\n    // --hard), or a file was deleted and then recreated by an editor like\n    // Vim. Because detecting changes can be costly, and because we care\n    // most about the settled state of the file system, we use the\n    // funcUtils.coalesce helper to delay calls to the callback by 100ms,\n    // canceling any additional calls if they happen within that window of\n    // time, so that a rapid succession of calls will tend to trigger only\n    // one inspection of the file system.\n    return coalesce(100, function onWatchEvent() {\n      if (self.stopped) {\n        return;\n      }\n\n      // This helper method will call self._fire() if the old and new stat\n      // objects have different types (missing, file, or directory), so we\n      // can assume they have the same type for the rest of this method.\n      var stat = self._updateStatForWatch(absPath);\n      if (self.stopped) {\n        return;\n      }\n\n      if (stat === null || stat.isFile()) {\n        if (_.has(self.watchSet.files, absPath)) {\n          self._fireIfFileChanged(absPath);\n          // XXX #3335 We probably should check again in a second, due to low\n          // filesystem modtime resolution.\n        }\n\n      } else if (stat.isDirectory()) {\n        try {\n          var dirFiles = files.readdir(absPath);\n        } catch (err) {\n          if (err.code === \"ENOENT\" ||\n              err.code === \"ENOTDIR\") {\n            // The directory was removed or changed type since we called\n            // self._updateStatForWatch, so we fire unconditionally.\n            self._fire();\n            return;\n          }\n          throw err;\n        }\n\n        _.each(dirFiles, function(file) {\n          var fullPath = files.pathJoin(absPath, file);\n\n          // Recursively watch new files, if we ever previously tried to\n          // watch them. Recall that when we attempt to watch a\n          // non-existent file, we actually watch the closest enclosing\n          // directory that exists, so once the file (and/or any\n          // intermediate directories) are created, we begin watching\n          // those directories in response to change events fired for\n          // directories we're already watching.\n          if (_.has(self.watches, fullPath)) {\n            self._watchFileOrDirectory(fullPath);\n          }\n        });\n\n        // If self.watchSet.directories contains any entries for the\n        // directory we are examining, call self._fireIfDirectoryChanged.\n        _.some(self.watchSet.directories, function(info) {\n          return self.stopped ||\n            (absPath === info.absPath &&\n             self._fireIfDirectoryChanged(info, true));\n          // XXX #3335 We probably should check again in a second, due to low\n          // filesystem modtime resolution.\n        });\n      }\n    });\n  }\n\n  // XXX Erk! This is wrong!  A null entry in a WatchSet means \"is not a file\",\n  // not \"does not exist\"; if you look at readAndWatchFileWithHash, \"a directory\n  // where a file was expected\" leads to the entry being null.  Right now this\n  // leads to infinite watcher refresh loops if something that needs to be a\n  // directory ends up as a file.  This all needs to be changed so that null\n  // means \"not a file\" again. A simple way to reproduce is to run\n  //    $ meteor --settings /tmp\n  // See #3854.\n  _mustNotExist(absPath) {\n    var wsFiles = this.watchSet.files;\n    if (_.has(wsFiles, absPath)) {\n      return wsFiles[absPath] === null;\n    }\n    return false;\n  }\n\n  _mustBeAFile(absPath) {\n    var wsFiles = this.watchSet.files;\n    if (_.has(wsFiles, absPath)) {\n      return _.isString(wsFiles[absPath]);\n    }\n    return false;\n  }\n\n  _updateStatForWatch(absPath) {\n    var self = this;\n    var entry = self.watches[absPath];\n    var lastStat = entry.lastStat;\n    var stat = files.statOrNull(absPath);\n    var mustNotExist = self._mustNotExist(absPath);\n    var mustBeAFile = self._mustBeAFile(absPath);\n\n    if (stat && lastStat === undefined) {\n      // We have not checked for this file before, so our expectations are\n      // somewhat relaxed (namely, we don't care about lastStat), but\n      // self._fire() might still need to be called if self.watchSet.files\n      // has conflicting expectations.\n      if (stat.isFile()) {\n        if (mustNotExist) {\n          self._fire();\n        }\n      } else if (stat.isDirectory()) {\n        if (mustNotExist || mustBeAFile) {\n          self._fire();\n        }\n      } else {\n        // Neither a file nor a directory, so treat as non-existent.\n        stat = null;\n        if (mustBeAFile) {\n          self._fire();\n        }\n      }\n\n      // We have not checked for this file before, so just record the new\n      // stat object.\n      entry.lastStat = stat;\n\n    } else if (stat && stat.isFile()) {\n      entry.lastStat = stat;\n      if (! lastStat || ! lastStat.isFile()) {\n        self._fire();\n      }\n\n    } else if (stat && stat.isDirectory()) {\n      entry.lastStat = stat;\n      if (! lastStat || ! lastStat.isDirectory()) {\n        self._fire();\n      }\n\n    } else {\n      entry.lastStat = stat = null;\n      if (lastStat) {\n        self._fire();\n      }\n    }\n\n    return stat;\n  }\n\n  _checkDirectories() {\n    var self = this;\n\n    if (self.stopped) {\n      return;\n    }\n\n    _.each(self.watchSet.directories, function (info) {\n      if (self.stopped) {\n        return;\n      }\n\n      if (! self.justCheckOnce) {\n        self._watchFileOrDirectory(info.absPath);\n      }\n\n      // Check for the case where by the time we created the watch, the\n      // directory has already changed.\n      self._fireIfDirectoryChanged(info);\n    });\n  }\n\n  _fire() {\n    var self = this;\n\n    if (self.stopped) {\n      return;\n    }\n\n    self.stop();\n    self.onChange();\n  }\n\n  stop() {\n    var self = this;\n    self.stopped = true;\n\n    // Clean up file watches\n    _.each(self.watches, function (entry) {\n      if (entry.watcher) {\n        entry.watcher.close();\n        entry.watcher = null;\n      }\n    });\n    self.watches = {};\n  }\n}\n\n// Given a WatchSet, returns true if it currently describes the state of the\n// disk.\nexport function isUpToDate(watchSet) {\n  return Profile.time('watch.isUpToDate', () => {\n    var upToDate = true;\n    var watcher = new Watcher({\n      watchSet: watchSet,\n      onChange: function () {\n        upToDate = false;\n      },\n      // internal flag which prevents us from starting watches and timers that\n      // we're about to cancel anyway\n      _justCheckOnce: true\n    });\n    watcher.stop();\n    return upToDate;\n  });\n}\n\n// Options should have absPath/include/exclude/names.\nexport function readAndWatchDirectory(watchSet, options) {\n  var contents = readDirectory(options);\n  watchSet.addDirectory(_.extend({contents: contents}, options));\n  return contents;\n}\n\n// Calculating the sha hash can be expensive for large files.  By\n// returning the calculated hash along with the file contents, the\n// hash doesn't need to be calculated again for static files.\n//\n// We only calculate the hash if needed here, so callers must not\n// *rely* on the hash being returned; merely that if the hash is\n// present, it is the correct hash of the contents.\nexport function readAndWatchFileWithHash(watchSet, absPath) {\n  var contents = readFile(absPath);\n  var hash = null;\n\n  // Allow null watchSet, if we want to use readFile-style error handling in a\n  // context where we might not always have a WatchSet (eg, reading\n  // settings.json where we watch for \"meteor run\" but not for \"meteor deploy\").\n  if (watchSet) {\n    hash = contents === null ? null : sha1(contents);\n    watchSet.addFile(absPath, hash);\n  }\n\n  return { contents, hash };\n}\n\nexport function readAndWatchFile(watchSet, absPath) {\n  return readAndWatchFileWithHash(watchSet, absPath).contents;\n}\n"]}