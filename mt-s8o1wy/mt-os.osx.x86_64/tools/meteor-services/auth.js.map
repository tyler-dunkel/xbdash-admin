{"version":3,"sources":["/tools/meteor-services/auth.js"],"names":["_","require","utils","files","config","httpHelpers","fiberHelpers","querystring","url","isopackets","Console","auth","exports","getLoadedPackages","load","openAccountsConnection","DDP","connect","getAuthDDPUrl","headers","getUserAgent","withAccountsConnection","f","self","conn","args","push","result","apply","close","loggedInAccountsConnection","token","connection","Promise","resolve","reject","resume","wait","err","error","await","sessionMethodCaller","methodName","options","session","getSessionId","getAccountsDomain","timer","cleanUp","clearTimeout","res","timeout","undefined","setTimeout","Error","then","setSessionId","readSessionData","sessionPath","getSessionFilePath","exists","JSON","parse","readFile","encoding","writeSessionData","data","tries","tempPath","pathJoin","pathDirname","Math","floor","random","fd","open","e","buf","Buffer","stringify","write","length","rename","getSession","sessionData","domain","sessions","ensureSessionType","type","has","each","keys","key","writeMeteorAccountsUsername","username","logOutAllSessions","logOutSession","crypto","userId","registrationUrl","pendingRevoke","Array","tokenId","loggedIn","currentUsername","removePendingRevoke","tokenIds","difference","tryRevokeOldTokens","extend","warned","domainsWithRevokedTokens","logoutFailWarning","firstTry","sendAuthorizeRequest","clientId","redirectUri","state","authCodeUrl","getOauthUrl","response_type","client_id","redirect_uri","codeResult","request","method","strictSSL","useAuthHeader","response","statusCode","location","hostname","oauthFlow","credentialToken","randomBytes","toString","authorizeResult","redirectResult","loginResult","oauth","credentialSecret","body","id","sessionType","doInteractivePasswordLogin","loginData","email","password","loginFailed","suppressErrorMessage","maybeCloseConnection","readLine","echo","prompt","stream","process","stderr","call","meteorAccountsLoginInfo","clientInfo","getAgentInfo","retry","doUsernamePasswordLogin","trim","loginCommand","overwriteExistingToken","loginOptions","logoutCommand","wasLoggedIn","alreadyPolledForRegistration","pollForRegistrationCompletion","noLogout","bindEnvironment","whoAmICommand","command","rawInfo","registerOrLogIn","methodCaller","validEmail","alreadyExisted","sentRegistrationEmail","animationFrame","lastLinePrinted","setInterval","spinner","rawError","CARRIAGE_RETURN","stopSpinner","join","clearInterval","waitForRegistrationResult","errorType","maybePrintRegistrationLink","leadingNewline","onlyAllowIfRegistered","firstTime","sessionId","getSessionToken","isLoggedIn","loggedInUsername","getAccountsConfiguration","accountsConfiguration","registerStore","update","msg","fields","service","serviceConfigurationsSub","subscribeAndWait","loginWithTokenOrOAuth","setUpOnReconnect","onReconnect","existingToken","loginStyle"],"mappings":"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","file":"tools/meteor-services/auth.js.map","sourcesContent":["var _ = require('underscore');\nvar utils = require('../utils/utils.js');\nvar files = require('../fs/files.js');\nvar config = require('./config.js');\nvar httpHelpers = require('../utils/http-helpers.js');\nvar fiberHelpers = require('../utils/fiber-helpers.js');\nvar querystring = require('querystring');\nvar url = require('url');\nvar isopackets = require('../tool-env/isopackets.js');\nvar Console = require('../console/console.js').Console;\n\nvar auth = exports;\n\nvar getLoadedPackages = function () {\n  return isopackets.load('ddp');\n};\n\n// Opens and returns a DDP connection to the accounts server. Remember\n// to close it when you're done with it!\nvar openAccountsConnection = function () {\n  var DDP = getLoadedPackages()['ddp-client'].DDP;\n  return DDP.connect(config.getAuthDDPUrl(), {\n    headers: { 'User-Agent': httpHelpers.getUserAgent() }\n  });\n};\n\n// Returns a function that runs `f`, appending an additional argument\n// that is a connection to the accounts server, which gets closed when\n// `f` returns or throws.\nvar withAccountsConnection = function (f) {\n  return function (...args) {\n    var self = this;\n    var conn = openAccountsConnection();\n    args.push(conn);\n    try {\n      var result = f.apply(self, args);\n    } finally {\n      conn.close();\n    }\n    return result;\n  };\n};\n\n// Open a DDP connection to the accounts server and log in using the\n// provided token. Returns the connection, or null if login fails.\n//\n// XXX if we reconnect we won't reauthenticate. Fix that before using\n// this for long-lived connections.\nvar loggedInAccountsConnection = function (token) {\n  var connection = getLoadedPackages()['ddp-client'].DDP.connect(\n    config.getAuthDDPUrl()\n  );\n\n  return new Promise(function (resolve, reject) {\n    connection.apply(\n      'login',\n      [{ resume: token }],\n      { wait: true },\n      function (err) {\n        err ? reject(err) : resolve(connection);\n      }\n    );\n\n  }).catch(function (err) {\n    connection.close();\n\n    if (err.error === 403) {\n      // This is not an ideal value for the error code, but it means\n      // \"server rejected our access token\". For example, it expired\n      // or we revoked it from the web.\n      return null;\n    }\n\n    // Something else went wrong\n    throw err;\n\n  }).await();\n};\n\n// The accounts server has some wrapped methods that take and return\n// session identifiers. To call these methods, we add our current\n// session identifier (or null, if we don't have one) as the last\n// argument to the method. The accounts server returns an object with\n// keys 'result' (the actual method result) and 'session' (the new\n// session identifier we should use, if it created a new session for\n// us).\n// options can include:\n//  - timeout: a timeout after which an exception will be thrown if the\n//    method hasn't returned yet\n//  - connection: an open connection to the accounts server. If not\n//    provided, one will be opened and then closed before returning.\nvar sessionMethodCaller = function (methodName, options) {\n  options = options || {};\n  return function (...args) {\n    args.push({\n      session: auth.getSessionId(config.getAccountsDomain()) || null\n    });\n\n    var timer;\n    var conn = options.connection || openAccountsConnection();\n\n    function cleanUp() {\n      timer && clearTimeout(timer);\n      options.connection || conn.close();\n    }\n\n    return new Promise(function (resolve, reject) {\n      conn.apply(methodName, args, function (err, res) {\n        err ? reject(err) : resolve(res);\n      });\n\n      if (options.timeout !== undefined) {\n        timer = setTimeout(function () {\n          reject(new Error('Method call timed out'));\n        }, options.timeout);\n      }\n\n    }).then(function (result) {\n      cleanUp();\n\n      if (result) {\n        if (result.session) {\n          // The bindEnvironment call above ensures the file IO operations\n          // that happen in auth.setSessionId take place in a Fiber.\n          auth.setSessionId(config.getAccountsDomain(), result.session);\n        }\n        result = result.result;\n      }\n\n      return result;\n\n    }, function (err) {\n      cleanUp();\n      throw err;\n\n    }).await();\n  };\n};\n\nvar readSessionData = function () {\n  var sessionPath = config.getSessionFilePath();\n  if (! files.exists(sessionPath)) {\n    return {};\n  }\n  return JSON.parse(files.readFile(sessionPath, { encoding: 'utf8' }));\n};\n\nvar writeSessionData = function (data) {\n  var sessionPath = config.getSessionFilePath();\n\n  var tries = 0;\n  while (true) {\n    if (tries++ > 10) {\n      throw new Error(\"can't find a unique name for temporary file?\");\n    }\n\n    // Create a temporary file in the same directory where we\n    // ultimately want to write the session file. Use the exclusive\n    // flag to atomically ensure that the file doesn't exist, create\n    // it, and make it readable and writable only by the current\n    // user (mode 0600).\n    var tempPath =\n          files.pathJoin(files.pathDirname(sessionPath), '.meteorsession.' +\n                    Math.floor(Math.random() * 999999));\n    try {\n      var fd = files.open(tempPath, 'wx', 0o600);\n    } catch (e) {\n      continue;\n    }\n\n    try {\n      // Write `data` to the file.\n      var buf = new Buffer(JSON.stringify(data, undefined, 2), 'utf8');\n      files.write(fd, buf, 0, buf.length, 0);\n    } finally {\n      files.close(fd);\n    }\n\n    // Atomically remove the old file (if any) and replace it with\n    // the temporary file we just created.\n    files.rename(tempPath, sessionPath);\n    return;\n  }\n};\n\nvar getSession = function (sessionData, domain) {\n  if (typeof (sessionData.sessions) !== \"object\") {\n    sessionData.sessions = {};\n  }\n  if (typeof (sessionData.sessions[domain]) !== \"object\") {\n    sessionData.sessions[domain] = {};\n  }\n  return sessionData.sessions[domain];\n};\n\n// types:\n// - \"meteor-account\": a login to your Meteor Account\n// We previously used:\n// - \"galaxy\": a login to a legacy Galaxy prototype server\nvar ensureSessionType = function (session, type) {\n  if (! _.has(session, 'type')) {\n    session.type = type;\n  } else if (session.type !== type) {\n    // Blow away whatever was there. We lose pendingRevokes but that's\n    // OK since this should never happen in normal operation. (It\n    // would happen if the Meteor Accounts server mode somewhere else\n    // and a Galaxy was deployed at its old address, for example).\n    _.each(_.keys(session), function (key) {\n      delete session[key];\n    });\n    session.type = type;\n  }\n};\n\nvar writeMeteorAccountsUsername = function (username) {\n  var data = readSessionData();\n  var session = getSession(data, config.getAccountsDomain());\n  session.username = username;\n  writeSessionData(data);\n};\n\n// Given an object 'data' in the format returned by readSessionData,\n// modify it to make the user logged out.\nvar logOutAllSessions = function (data) {\n  _.each(data.sessions, function (session, domain) {\n    logOutSession(session);\n  });\n};\n\n// As logOutAllSessions, but for a session on a particular domain\n// rather than all sessions.\nvar logOutSession = function (session) {\n  var crypto = require('crypto');\n\n  delete session.username;\n  delete session.userId;\n  delete session.registrationUrl;\n\n  if (_.has(session, 'token')) {\n    if (! (session.pendingRevoke instanceof Array)) {\n      session.pendingRevoke = [];\n    }\n\n    // Delete the auth token itself, but save the tokenId, which is\n    // useless for authentication. The next time we're online, we'll\n    // send the tokenId to the server to revoke the token on the\n    // server side too.\n    if (typeof session.tokenId === \"string\") {\n      session.pendingRevoke.push(session.tokenId);\n    }\n    delete session.token;\n    delete session.tokenId;\n  }\n};\n\n// Given an object 'data' in the format returned by readSessionData,\n// return true if logged in, else false.\nvar loggedIn = function (data) {\n  return !! getSession(data, config.getAccountsDomain()).userId;\n};\n\n// Given an object 'data' in the format returned by readSessionData,\n// return the currently logged in user, or null if not logged in or if\n// the logged in user doesn't have a username.\nvar currentUsername = function (data) {\n  var sessionData = getSession(data, config.getAccountsDomain());\n  return sessionData.username || null;\n};\n\nvar removePendingRevoke = function (domain, tokenIds) {\n  var data = readSessionData();\n  var session = getSession(data, domain);\n  session.pendingRevoke = _.difference(session.pendingRevoke, tokenIds);\n  if (! session.pendingRevoke.length) {\n    delete session.pendingRevoke;\n  }\n  writeSessionData(data);\n};\n\n// If there are any logged out (pendingRevoke) tokens that haven't\n// been sent to the server for revocation yet, try to send\n// them. Reads the session file and then writes it back out to\n// disk. If the server can't be contacted, fail silently (and leave\n// the pending invalidations in the session file for next time).\n//\n// options:\n//  - timeout: request timeout in milliseconds\n//  - firstTry: cosmetic. set to true if we recently logged out a\n//    session. just changes the error message.\n//  - connection: an open connection to the accounts server. If not\n//    provided, this function will open one itself.\nvar tryRevokeOldTokens = function (options) {\n  options = _.extend({\n    timeout: 5000\n  }, options || {});\n\n  var warned = false;\n  var domainsWithRevokedTokens = [];\n  _.each(readSessionData().sessions || {}, function (session, domain) {\n    if (session.pendingRevoke &&\n        session.pendingRevoke.length) {\n      domainsWithRevokedTokens.push(domain);\n    }\n  });\n\n  var logoutFailWarning = function (domain) {\n    if (! warned) {\n      // This isn't ideal but is probably better that saying nothing at all\n      Console.error(\"warning: \" +\n                    (options.firstTry ?\n                    \"couldn't\" : \"still trying to\") +\n                     \" confirm logout with \" + domain);\n      warned = true;\n    }\n  };\n\n  _.each(domainsWithRevokedTokens, function (domain) {\n    var data = readSessionData();\n    var session = data.sessions[domain] || {};\n    var tokenIds = session.pendingRevoke || [];\n    if (! tokenIds.length) {\n      return;\n    }\n\n    var url;\n\n\n    if (session.type === \"meteor-account\") {\n      try {\n        sessionMethodCaller('revoke', {\n          timeout: options.timeout,\n          connection: options.connection\n        })(tokenIds);\n        removePendingRevoke(domain, tokenIds);\n      } catch (err) {\n        logoutFailWarning(domain);\n      }\n      return;\n    } else if (session.type === \"galaxy\") {\n      // These are tokens from a legacy Galaxy prototype, which cannot be\n      // revoked (because the prototype no longer exists), but we can at least\n      // remove them from the file.\n      removePendingRevoke(domain, tokenIds);\n    } else {\n      // don't know how to revoke tokens of this type\n      logoutFailWarning(domain);\n      return;\n    }\n  });\n};\n\nvar sendAuthorizeRequest = function (clientId, redirectUri, state) {\n  var authCodeUrl = config.getOauthUrl() + \"/authorize?\" +\n        querystring.stringify({\n          state: state,\n          response_type: \"code\",\n          client_id: clientId,\n          redirect_uri: redirectUri\n        });\n\n  // It's very important that we don't have request follow the\n  // redirect for us, but instead issue the second request ourselves,\n  // since request would pass our credentials along to the redirected\n  // URL. See comments in http-helpers.js.\n  var codeResult = httpHelpers.request({\n    url: authCodeUrl,\n    method: 'POST',\n    strictSSL: true,\n    useAuthHeader: true\n  });\n\n  var response = codeResult.response;\n  if (response.statusCode !== 302 || ! response.headers.location) {\n    throw new Error('access-denied');\n  }\n\n  if (url.parse(response.headers.location).hostname !==\n      url.parse(redirectUri).hostname) {\n    // If we didn't get an immediate redirect to the redirectUri then\n    // presumably the oauth server is trying to interact with us (make\n    // us log in, authorize the client, or something like that). We're\n    // not a web browser so we can't participate in such things.\n    throw new Error('access-denied');\n  }\n\n  return { location: response.headers.location };\n};\n\n// Do an OAuth flow with the Meteor developer accounts server to log in\n// to an OAuth client. `conn` is expected to be a DDP connection to the\n// OAuth client app. Options are:\n//  - clientId: OAuth client id parameter\n//  - redirectUri: OAuth redirect_uri parameter\n//  - domain: the domain for saving the received login token on success\n//    in the Meteor session file\n//  - sessionType: the value of the 'type' field for the session saved\n//    in the Meteor session file on success\n// All options are required.\n//\n// Throws an error if the login is not successful.\nvar oauthFlow = function (conn, options) {\n  var crypto = require('crypto');\n  var credentialToken = crypto.randomBytes(16).toString('hex');\n\n  var authorizeResult = sendAuthorizeRequest(\n    options.clientId,\n    options.redirectUri,\n    credentialToken\n  );\n\n  // XXX We're using a test-only flag here to just get the raw\n  // credential secret (instead of a bunch of code that communicates the\n  // credential secret somewhere else); this should be temporary until\n  // we give this a nicer name and make it not just test only.\n  var redirectResult = httpHelpers.request({\n    url: authorizeResult.location + '&only_credential_secret_for_test=1',\n    method: 'GET',\n    strictSSL: true\n  });\n\n  var response = redirectResult.response;\n  // 'access-denied' isn't exactly right because it's possible that the server\n  // went down since our last request, but close enough.\n\n  if (response.statusCode !== 200) {\n    throw new Error('access-denied');\n  }\n\n  // XXX tokenId???\n  var loginResult = conn.apply('login', [{\n    oauth: {\n      credentialToken: credentialToken,\n      credentialSecret: response.body\n    }\n  }], { wait: true });\n\n  if (loginResult.token && loginResult.id) {\n    var data = readSessionData();\n    var session = getSession(data, options.domain);\n    ensureSessionType(session, options.sessionType);\n    session.token = loginResult.token;\n    writeSessionData(data);\n    return true;\n  } else {\n    throw new Error('login-failed');\n  }\n};\n\n// Prompt the user for a password, and then log in. Returns true if a\n// successful login was accomplished, else false.\n//\n// Options should include either 'email' or 'username', and may also\n// include:\n// - retry: if true, then if the user gets the password wrong,\n//   reprompt.\n// - suppressErrorMessage: true if the function should not print an\n//   error message to stderr if the login fails\n// - connection: an open connection to the accounts server. If not\n//   provided, this function will open its own connection.\nvar doInteractivePasswordLogin = function (options) {\n  var loginData = {};\n\n  if (_.has(options, 'username')) {\n    loginData.username = options.username;\n  } else if (_.has(options, 'email')) {\n    loginData.email = options.email;\n  } else {\n    throw new Error(\"Need username or email\");\n  }\n\n  if (_.has(options, 'password')) {\n    loginData.password = options.password;\n  }\n\n  var loginFailed = function () {\n    if (! options.suppressErrorMessage) {\n      Console.error(\"Login failed.\");\n    }\n  };\n\n  var conn = options.connection || openAccountsConnection();\n\n  var maybeCloseConnection = function () {\n    if (! options.connection) {\n      conn.close();\n    }\n  };\n\n  while (true) {\n    if (! _.has(loginData, 'password')) {\n      loginData.password = Console.readLine({\n        echo: false,\n        prompt: \"Password: \",\n        stream: process.stderr\n      });\n    }\n\n    try {\n      var result = conn.call('login', {\n        session: auth.getSessionId(config.getAccountsDomain()),\n        meteorAccountsLoginInfo: loginData,\n        clientInfo: utils.getAgentInfo()\n      });\n    } catch (err) {\n    }\n    if (result && result.token) {\n      break;\n    } else {\n      loginFailed();\n      if (options.retry) {\n        Console.error();\n        continue;\n      } else {\n        maybeCloseConnection();\n        return false;\n      }\n    }\n  }\n\n  if (result.session) {\n    auth.setSessionId(config.getAccountsDomain(), result.session);\n  }\n\n  var data = readSessionData();\n  logOutAllSessions(data);\n  var session = getSession(data, config.getAccountsDomain());\n  ensureSessionType(session, \"meteor-account\");\n  session.username = result.username;\n  session.userId = result.id;\n  session.token = result.token;\n  session.tokenId = result.tokenId;\n  writeSessionData(data);\n  maybeCloseConnection();\n  return true;\n};\n\n// options are the same as for doInteractivePasswordLogin, except without\n// username and email.\nexports.doUsernamePasswordLogin = function (options) {\n  var username;\n\n  do {\n    username = Console.readLine({\n      prompt: \"Username: \",\n      stream: process.stderr\n    }).trim();\n  } while (username.length === 0);\n\n  return doInteractivePasswordLogin(_.extend({}, options, {\n    username: username\n  }));\n};\n\nexports.doInteractivePasswordLogin = doInteractivePasswordLogin;\n\nexports.loginCommand = withAccountsConnection(function (options,\n                                                        connection) {\n  var data = readSessionData();\n\n  if (! getSession(data, config.getAccountsDomain()).token ||\n       options.overwriteExistingToken) {\n    var loginOptions = {};\n\n    if (options.email) {\n      loginOptions.email = Console.readLine({\n        prompt: \"Email: \",\n        stream: process.stderr\n      });\n    } else {\n      loginOptions.username = Console.readLine({\n        prompt: \"Username: \",\n        stream: process.stderr\n      });\n    }\n\n    loginOptions.connection = connection;\n\n    if (! doInteractivePasswordLogin(loginOptions)) {\n      return 1;\n    }\n  }\n\n  tryRevokeOldTokens({ firstTry: true, connection: connection });\n\n  data = readSessionData();\n  Console.error();\n  Console.error(\"Logged in\" +\n                (currentUsername(data) ? \" as \" + currentUsername(data) : \"\") +\n                \". Thanks for being a Meteor developer!\");\n  return 0;\n});\n\nexports.logoutCommand = function (options) {\n  var data = readSessionData();\n  var wasLoggedIn = !! loggedIn(data);\n  logOutAllSessions(data);\n  writeSessionData(data);\n\n  tryRevokeOldTokens({ firstTry: true });\n\n  if (wasLoggedIn) {\n    Console.error(\"Logged out.\");\n  } else {\n    // We called logOutAllSessions/writeSessionData anyway, out of an\n    // abundance of caution.\n    Console.error(\"Not logged in.\");\n  }\n};\n\n// If this is fully set up account (with a username and password), or\n// if not logged in, do nothing. If it is an account without a\n// username, contact the server and see if the user finished setting\n// it up, and if so grab and save the username. But contact the server\n// only once per run of the program. Options:\n//  - noLogout: boolean. Set to true if you don't want this function to\n//    log out the session if wehave an invalid credential (for example,\n//    if a caller wants to do its own error handling for invalid\n//    credentials). Defaults to false.\nvar alreadyPolledForRegistration = false;\nexports.pollForRegistrationCompletion = function (options) {\n  if (alreadyPolledForRegistration) {\n    return;\n  }\n  alreadyPolledForRegistration = true;\n\n  options = options || {};\n\n  var data = readSessionData();\n  var session = getSession(data, config.getAccountsDomain());\n  if (session.username || ! session.token) {\n    return;\n  }\n\n  // We are logged in but we don't yet have a username. Ask the server\n  // if a username was chosen since we last checked.\n  var username = null;\n  var connection = loggedInAccountsConnection(session.token);\n  var timer;\n\n  if (! connection) {\n    // Server says our credential isn't any good anymore! Get rid of\n    // it. Note that, out of an abundance of caution, this also will\n    // enqueue the credential for invalidation (on a future run, we\n    // will try to explicitly revoke the credential ourselves).\n    if (! options.noLogout) {\n      logOutSession(session);\n      writeSessionData(data);\n    }\n    return;\n  }\n\n  new Promise(function (resolve) {\n    connection.call('getUsername', function (err, username) {\n      // If anything went wrong, return null just as we would have if we\n      // hadn't bothered to ask the server.\n      resolve(err ? null : username);\n    });\n\n    timer = setTimeout(function () {\n      resolve(null);\n    }, 5000);\n\n  // Intentionally calling bindEnvironment on the .then callback rather\n  // than the function that calls resolve.\n  }).then(fiberHelpers.bindEnvironment(function (username) {\n    connection.close();\n    clearTimeout(timer);\n\n    if (username) {\n      writeMeteorAccountsUsername(username);\n    }\n\n  // We don't actually care about the result, just that the side-effects\n  // of writeMeteorAccountsUsername happen.\n  })).await();\n};\n\nexports.registrationUrl = function () {\n  var data = readSessionData();\n  var url = getSession(data, config.getAccountsDomain()).registrationUrl;\n  return url;\n};\n\nexports.whoAmICommand = function (options) {\n  auth.pollForRegistrationCompletion();\n\n  var data = readSessionData();\n  if (! loggedIn(data)) {\n    Console.error(\n      \"Not logged in. \" + Console.command(\"'meteor login'\") + \" to log in.\");\n    return 1;\n  }\n\n  var username = currentUsername(data);\n  if (username) {\n    Console.rawInfo(username + \"\\n\");\n    return 0;\n  }\n\n  var url = getSession(data, config.getAccountsDomain()).registrationUrl;\n  if (url) {\n    Console.error(\"You haven't chosen your username yet. To pick it, go here:\");\n    Console.error();\n    Console.error(Console.url(url));\n  } else {\n    // Won't happen in normal operation\n    Console.error(\"You haven't chosen your username yet.\");\n  }\n\n  return 1;\n};\n\n// Prompt for an email address. If it doesn't belong to a user, create\n// a new deferred registration account and log in as it. If it does,\n// try to log the user into it. Returns true on success (user is now\n// logged in) or false on failure (user gave up, can't talk to\n// network..)\nexports.registerOrLogIn = withAccountsConnection(function (connection) {\n  var result;\n  // Get their email\n  while (true) {\n    var email = Console.readLine({\n      prompt: \"Email: \",\n      stream: process.stderr\n    });\n\n    // Try to register\n    try {\n      var methodCaller = sessionMethodCaller(\n        'tryRegister',\n        { connection: connection }\n      );\n      result = methodCaller(email, utils.getAgentInfo());\n      break;\n    } catch (err) {\n      if (err.error === 400 && ! utils.validEmail(email)) {\n        if (email.trim().length) {\n          Console.error(\"Please double-check that address.\");\n          Console.error();\n        }\n      } else {\n        Console.error(\"\\nCouldn't connect to server. \" +\n                             \"Check your internet connection.\");\n        return false;\n      }\n    }\n  }\n\n  var loginResult;\n\n  if (! result.alreadyExisted) {\n    var data = readSessionData();\n    logOutAllSessions(data);\n    var session = getSession(data, config.getAccountsDomain());\n    ensureSessionType(session, \"meteor-account\");\n    session.token = result.token;\n    session.tokenId = result.tokenId;\n    session.userId = result.userId;\n    session.registrationUrl = result.registrationUrl;\n    writeSessionData(data);\n    return true;\n  } else if (result.alreadyExisted && result.sentRegistrationEmail) {\n    Console.error();\n    Console.error(\n      \"You need to pick a password for your account so that you can log in.\",\n      \"An email has been sent to you with the link.\");\n    Console.error();\n\n    var animationFrame = 0;\n    var lastLinePrinted = \"\";\n    var timer = setInterval(function () {\n      var spinner = ['-', '\\\\', '|', '/'];\n      lastLinePrinted = \"Waiting for you to register on the web... \" +\n        spinner[animationFrame];\n      Console.rawError(lastLinePrinted + Console.CARRIAGE_RETURN);\n      animationFrame = (animationFrame + 1) % spinner.length;\n    }, 200);\n    var stopSpinner = function () {\n      Console.rawError(new Array(lastLinePrinted.length + 1).join(' ') +\n                       Console.CARRIAGE_RETURN);\n      clearInterval(timer);\n    };\n\n    try {\n      var waitForRegistrationResult = connection.call(\n        'waitForRegistration',\n        email\n      );\n    } catch (e) {\n      stopSpinner();\n      if (e.errorType !== \"Meteor.Error\") {\n        throw e;\n      }\n      Console.error(\n        \"When you've picked your password, run \" +\n        Console.command(\"'meteor login'\") + \" to log in.\");\n      return false;\n    }\n\n    stopSpinner();\n    Console.error(\"Username: \" + waitForRegistrationResult.username);\n    loginResult = doInteractivePasswordLogin({\n      username: waitForRegistrationResult.username,\n      retry: true,\n      connection: connection\n    });\n    return loginResult;\n  } else if (result.alreadyExisted && result.username) {\n    Console.error(\"\\nLogging in as \" + Console.command(result.username) + \".\");\n\n    loginResult = doInteractivePasswordLogin({\n      username: result.username,\n      retry: true,\n      connection: connection\n    });\n    return loginResult;\n  } else {\n    // Hmm, got an email we don't understand.\n    Console.error(\n      \"\\nThere was a problem. Please log in with \" +\n      Console.command(\"'meteor login'\") + \".\");\n    return false;\n  }\n});\n\n// options: firstTime, leadingNewline\n// returns true if it printed something\nexports.maybePrintRegistrationLink = function (options) {\n  options = options || {};\n\n  auth.pollForRegistrationCompletion();\n\n  var data = readSessionData();\n  var session = getSession(data, config.getAccountsDomain());\n\n  if (session.userId && ! session.username && session.registrationUrl) {\n    if (options.leadingNewline) {\n      Console.error();\n    }\n    if (options.onlyAllowIfRegistered) {\n      // A stronger message: we're going to not allow whatever they were trying\n      // to do!\n      Console.error(\n        \"You need to claim a username and set a password on your Meteor\",\n        \"developer account to run this command. It takes about a minute at:\",\n        session.registrationUrl);\n      Console.error();\n    } else if (! options.firstTime) {\n      // If they've already been prompted to set a password then this\n      // is more of a friendly reminder, so we word it slightly\n      // differently than the first time they're being shown a\n      // registration url.\n      Console.error(\n        \"You should set a password on your Meteor developer account.\",\n        \"It takes about a minute at:\", session.registrationUrl);\n      Console.error();\n    } else {\n      Console.error(\n        \"You can set a password on your account or change your email\",\n        \"address at:\", session.registrationUrl);\n      Console.error();\n    }\n    return true;\n  }\n  return false;\n};\n\nexports.tryRevokeOldTokens = tryRevokeOldTokens;\n\nexports.getSessionId = function (domain, sessionData) {\n  sessionData = sessionData || readSessionData();\n  return getSession(sessionData, domain).session;\n};\n\nexports.setSessionId = function (domain, sessionId) {\n  var data = readSessionData();\n  getSession(data, domain).session = sessionId;\n  writeSessionData(data);\n};\n\nexports.getSessionToken = function (domain) {\n  return getSession(readSessionData(), domain).token;\n};\n\nexports.isLoggedIn = function () {\n  return loggedIn(readSessionData());\n};\n\n// Return the username of the currently logged in user, or false if\n// not logged in, or null if the logged in user doesn't have a\n// username.\nexports.loggedInUsername = function () {\n  var data = readSessionData();\n  return loggedIn(data) ? currentUsername(data) : false;\n};\n\nexports.getAccountsConfiguration = function (conn) {\n  // Subscribe to the package server's service configurations so that we\n  // can get the OAuth client ID to kick off the OAuth flow.\n  var accountsConfiguration = null;\n\n  // We avoid the overhead of creating a 'ddp-and-mongo' isopacket (or\n  // always loading mongo whenever we load ddp) by just using the low-level\n  // DDP client API here.\n  conn.connection.registerStore('meteor_accounts_loginServiceConfiguration', {\n    update: function (msg) {\n      if (msg.msg === 'added' && msg.fields &&\n          msg.fields.service === 'meteor-developer') {\n        // Note that this doesn't include the _id (which we'd have to parse),\n        // but that's OK.\n        accountsConfiguration = msg.fields;\n      }\n    }\n  });\n\n  var serviceConfigurationsSub = conn.subscribeAndWait(\n    'meteor.loginServiceConfiguration');\n  if (! accountsConfiguration || ! accountsConfiguration.clientId) {\n    throw new Error('no-accounts-configuration');\n  }\n\n  return accountsConfiguration;\n};\n\n// Given a ServiceConnection, log in with OAuth using Meteor developer\n// accounts. Assumes the user is already logged in to the developer\n// accounts server.\nexports.loginWithTokenOrOAuth = function (conn, accountsConfiguration,\n                                          url, domain, sessionType) {\n  var setUpOnReconnect = function () {\n    conn.onReconnect = function () {\n      conn.apply('login', [{\n        resume: auth.getSessionToken(domain)\n      }], { wait: true }, function () { });\n    };\n  };\n\n  var clientId = accountsConfiguration.clientId;\n  var loginResult;\n\n  // Try to log in with an existing login token, if we have one.\n  var existingToken = auth.getSessionToken(domain);\n  if (existingToken) {\n    try {\n      loginResult = conn.apply('login', [{\n        resume: existingToken\n      }], { wait: true });\n    } catch (err) {\n      // If we get a Meteor.Error, then we swallow it and go on to\n      // attempt an OAuth flow and get a new token. If it's not a\n      // Meteor.Error, then we leave it to the caller to handle.\n      if (err.errorType !== \"Meteor.Error\") {\n        throw err;\n      }\n    }\n\n    if (loginResult && loginResult.token && loginResult.id) {\n      // Success!\n      setUpOnReconnect();\n      return;\n    }\n  }\n\n  // Either we didn't have an existing token, or it didn't work. Do an\n  // OAuth flow to log in.\n  var redirectUri = url + '/_oauth/meteor-developer';\n\n  // Duplicate code from packages/oauth/oauth_common.js. In Meteor 0.9.1, we\n  // switched to a new URL style for Oauth that no longer has the \"?close\"\n  // parameter at the end. However, we need all of our backend services to be\n  // compatible with old Meteor tools which were written before 0.9.1. These old\n  // meteor tools only know how to deal with oauth URLs that have the \"?close\"\n  // query parameter, so our services (packages.meteor.com, etc) have to use the\n  // old-style URL. This means that all new Meteor tools also need to use the\n  // old-style URL to be compatible with the new servers which are backwards-\n  // compatible with the old tool.\n  if (! accountsConfiguration.loginStyle) {\n    redirectUri = redirectUri + \"?close\";\n  }\n  loginResult = oauthFlow(conn, {\n    clientId: clientId,\n    redirectUri: redirectUri,\n    domain: domain,\n    sessionType: sessionType\n  });\n\n  setUpOnReconnect();\n};\n\nexports.loggedInAccountsConnection = loggedInAccountsConnection;\nexports.withAccountsConnection = withAccountsConnection;\n"]}