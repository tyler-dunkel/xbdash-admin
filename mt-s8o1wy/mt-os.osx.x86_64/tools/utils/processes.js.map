{"version":3,"sources":["/tools/utils/processes.js"],"names":["_","child_process","files","execFileSync","command","args","options","Promise","await","execFileAsync","waitForClose","Array","isArray","extend","cwd","convertToOSPath","exitEvent","resolve","reject","child","process","platform","spawn","env","stdio","forEach","arg","exec","capturedStdout","stdout","destination","pipe","setEncoding","on","data","capturedStderr","stderr","errorCallback","error","removeListener","exitCallback","trim","pid","code","message","signal","errorMessage","join","Error","status"],"mappings":"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","file":"tools/utils/processes.js.map","sourcesContent":["import _ from 'underscore';\nimport child_process from 'child_process';\nimport files from '../fs/mini-files';\n\n// The execFileSync function is meant to resemble the similarly-named Node 0.12\n// synchronous process creation API, but instead of being fully blocking it\n// uses a promise-based implementation. You can also use\n// execFileAsync directly, which returns a promise.\n// Some functionality is currently missing but could be added when the need\n// arises (e.g. support for timeout, maxBuffer, and encoding options).\n// Eventually, these versions should replace the ones in tools/utils/utils.js\n// and tools/tool-testing/selftest.js.\n\n/**\n * @summary Executes a command synchronously, returning either the captured\n * stdout output or throwing an error containing the stderr output as part of\n * the message. In addition, the error will contain fields pid, stderr, stdout,\n * status and signal.\n * @param {String} command The command to run\n * @param {Array} [args] List of string arguments\n * @param {Object} [options]\n * @param {Object} [options.cwd] Current working directory of the child process\n * @param {Object} [options.env] Environment key-value pairs\n * @param {Array|String} [options.stdio] Child's stdio configuration.\n * (Default: 'pipe') Specifying anything else than 'pipe' will disallow\n * capture.\n * @param {Writable} [options.destination] If specified, instead of capturing\n * the output, the child process stdout will be piped to the destination stream.\n * @param {String} [options.waitForClose] Whether to wait for the child process\n * streams to close or to resolve the promise when the child process exits.\n * @returns {String} The stdout from the command\n */\nexport function execFileSync(command, args, options) {\n  return Promise.await(execFileAsync(command, args, options));\n}\n\n/**\n * @summary Executes a command asynchronously, returning a promise that will\n * either be resolved to the captured stdout output or be rejected with an\n * error containing the stderr output as part of the message. In addition,\n * the error will contain fields pid, stderr, stdout, status and signal.\n * @param {String} command The command to run\n * @param {Array} [args] List of string arguments\n * @param {Object} [options]\n * @param {Object} [options.cwd] Current working directory of the child process\n * @param {Object} [options.env] Environment key-value pairs\n * @param {Array|String} [options.stdio] Child's stdio configuration.\n * (Default: 'pipe') Specifying anything else than 'pipe' will disallow\n * capture.\n * @param {Writable} [options.destination] If specified, instead of capturing\n * the output, the child process stdout will be piped to the destination stream.\n * @param {String} [options.waitForClose] Whether to wait for the child process\n * streams to close or to resolve the promise when the child process exits.\n * @returns {Promise<String>}\n */\nexport function execFileAsync(command, args,\n  options = { waitForClose: true }) {\n  // args is optional, so if it's not an array we interpret it as options\n  if (!Array.isArray(args)) {\n    options = _.extend(options, args);\n    args = [];\n  }\n  if (options.cwd) {\n    options.cwd = files.convertToOSPath(options.cwd);\n  }\n  // The child process close event is emitted when the stdio streams\n  // have all terminated. If those streams are shared with other\n  // processes, that means we won't receive a 'close' until all processes\n  // have exited, so we may want to respond to 'exit' instead.\n  // (The downside of responding to 'exit' is that the streams may not be\n  // fully flushed, so we could miss captured output. Only use this\n  // option when needed.)\n  const exitEvent = options.waitForClose ? 'close' : 'exit';\n\n  return new Promise((resolve, reject) => {\n    var child; \n\n    if (process.platform !== 'win32') {\n      child = child_process.spawn(command, args,\n      { cwd, env, stdio } = options);\n    } else {\n      // https://github.com/nodejs/node-v0.x-archive/issues/2318\n      args.forEach(arg => {\n        command += ' ' + arg;\n      });\n      child = child_process.exec(command,\n      { cwd, env, stdio } = options);\n    }\n\n    let capturedStdout = '';\n    if (child.stdout) {\n      if (options.destination) {\n        child.stdout.pipe(options.destination);\n      } else {\n        child.stdout.setEncoding('utf8');\n        child.stdout.on('data', (data) => {\n          capturedStdout += data;\n        });\n      }\n    }\n\n    let capturedStderr = '';\n    if (child.stderr) {\n      child.stderr.setEncoding('utf8');\n      child.stderr.on('data', (data) => {\n        capturedStderr += data;\n      });\n    }\n\n    const errorCallback = (error) => {\n      // Make sure we only receive one type of callback\n      child.removeListener(exitEvent, exitCallback);\n\n      // Trim captured output to get rid of excess whitespace\n      capturedStdout = capturedStdout.trim();\n      capturedStderr = capturedStderr.trim();\n\n      _.extend(error, {\n        pid: child.pid,\n        stdout: capturedStdout,\n        stderr: capturedStderr,\n      });\n\n      // Set a more informative error message on ENOENT, that includes the\n      // command we attempted to execute\n      if (error.code === 'ENOENT') {\n        error.message = `Could not find command '${command}'`;\n      }\n\n      reject(error);\n    };\n    child.on('error', errorCallback);\n\n    const exitCallback = (code, signal) => {\n      // Make sure we only receive one type of callback\n      child.removeListener('error', errorCallback);\n\n      // Trim captured output to get rid of excess whitespace\n      capturedStdout = capturedStdout.trim();\n      capturedStderr = capturedStderr.trim();\n\n      if (code === 0) {\n        resolve(capturedStdout);\n      } else {\n        let errorMessage = `Command failed: ${command}`;\n        if (args) {\n          errorMessage += ` ${args.join(' ')}`;\n        }\n        errorMessage += `\\n${capturedStderr}`;\n\n        const error = new Error(errorMessage);\n\n        _.extend(error, {\n          pid: child.pid,\n          stdout: capturedStdout,\n          stderr: capturedStderr,\n          status: code,\n          signal: signal\n        });\n\n        reject(error);\n      }\n    };\n    child.on(exitEvent, exitCallback);\n  });\n}\n"]}