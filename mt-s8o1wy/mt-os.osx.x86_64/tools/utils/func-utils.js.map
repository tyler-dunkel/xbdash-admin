{"version":3,"sources":["/tools/utils/func-utils.js"],"names":["exports","coalesce","delayMs","callback","context","pending","inProgress","coalescingWrapper","self","Promise","setTimeout","resolve","then","thenCallback","call","wrap","wrapper","wrapped","prototype","name","displayName"],"mappings":"AAAA;AACA;AACA;AACAA,QAAQC,QAAR,GAAmB,UAASC,OAAT,EAAkBC,QAAlB,EAA4BC,OAA5B,EAAqC;AACtD,MAAIC,UAAU,KAAd;AACA,MAAIC,aAAa,CAAjB;;AAEAJ,YAAUA,WAAW,GAArB;;AAEA,WAASK,iBAAT,GAA6B;AAC3B,QAAIC,OAAOJ,WAAW,IAAtB;;AAEA,QAAIE,UAAJ,EAAgB;AACd;AACA;AACA,QAAEA,UAAF;AACA;AACD;;AAED,QAAID,OAAJ,EAAa;AACX;AACA;AACD;;AAED,QAAII,OAAJ,CACE;AAAA,aAAWC,WAAWC,OAAX,EAAoBT,OAApB,CAAX;AAAA,KADF,EAEEU,IAFF,CAEO,SAASC,YAAT,GAAwB;AAC7B;AACA;AACA;AACA;AACA;AACAR,gBAAU,KAAV;AACAC,mBAAa,CAAb;;AAEA,UAAI;AACFH,iBAASW,IAAT,CAAcN,IAAd;AACD,OAFD,SAEU;AACR,YAAIF,aAAa,CAAjB,EAAoB;AAClBG,kBAAQE,OAAR,GAAkBC,IAAlB,CAAuBC,YAAvB;AACAR,oBAAU,IAAV;AACD;AACDC,qBAAa,CAAb;AACD;AACF,KApBD;AAqBD;;AAED,SAAOS,KAAKR,iBAAL,EAAwBJ,QAAxB,CAAP;AACD,CA7CD;;AA+CA,SAASY,IAAT,CAAcC,OAAd,EAAuBC,OAAvB,EAAgC;AAC9B;AACA;AACAD,UAAQE,SAAR,GAAoBD,QAAQC,SAA5B;;AAEA;AACA,MAAIC,OAAOF,QAAQG,WAAR,IAAuBH,QAAQE,IAA1C;AACA,MAAIA,IAAJ,EAAU;AACRH,YAAQI,WAAR,GAAsBD,IAAtB;AACD;;AAED,SAAOH,OAAP;AACD","file":"tools/utils/func-utils.js.map","sourcesContent":["// Return a function that coalesceses calls to fn that occur within delay\n// milliseconds of each other, and prevents overlapping invocations of fn\n// by postponing the next invocation until after fn's fiber finishes.\nexports.coalesce = function(delayMs, callback, context) {\n  var pending = false;\n  var inProgress = 0;\n\n  delayMs = delayMs || 100;\n\n  function coalescingWrapper() {\n    var self = context || this;\n\n    if (inProgress) {\n      // Indicate that coalescingWrapper should be called again after the\n      // callback is no longer in progress.\n      ++inProgress;\n      return;\n    }\n\n    if (pending) {\n      // Defer to the already-pending timer.\n      return;\n    }\n\n    new Promise(\n      resolve => setTimeout(resolve, delayMs)\n    ).then(function thenCallback() {\n      // Now that the timeout has fired, set inProgress to 1 so that\n      // (until the callback is complete and we set inProgress to 0 again)\n      // any calls to coalescingWrapper will increment inProgress to\n      // indicate that at least one other caller wants fiberCallback to be\n      // called again when the original callback is complete.\n      pending = false;\n      inProgress = 1;\n\n      try {\n        callback.call(self);\n      } finally {\n        if (inProgress > 1) {\n          Promise.resolve().then(thenCallback);\n          pending = true;\n        }\n        inProgress = 0;\n      }\n    });\n  }\n\n  return wrap(coalescingWrapper, callback);\n};\n\nfunction wrap(wrapper, wrapped) {\n  // Allow the wrapper to be used as a constructor function, just in case\n  // the wrapped function was meant to be used as a constructor.\n  wrapper.prototype = wrapped.prototype;\n\n  // https://medium.com/@cramforce/on-the-awesomeness-of-fn-displayname-9511933a714a\n  var name = wrapped.displayName || wrapped.name;\n  if (name) {\n    wrapper.displayName = name;\n  }\n\n  return wrapper;\n}\n"]}