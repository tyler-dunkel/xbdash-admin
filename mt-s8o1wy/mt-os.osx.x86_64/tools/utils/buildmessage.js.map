{"version":3,"sources":["/tools/utils/buildmessage.js"],"names":["_","require","files","parseStack","fiberHelpers","Progress","debugBuild","process","env","METEOR_DEBUG_BUILD","Job","options","self","messages","title","rootPath","children","extend","prototype","addMessage","push","hasMessages","length","hasMessageWithTag","tagName","any","message","tags","has","formatMessages","indent","out","already","Array","join","each","stack","line","file","column","func","frame","where","MessageSet","messageSet","jobs","clone","jobsWithMessages","filter","job","map","merge","j","spaces","n","times","currentMessageSet","EnvironmentVariable","currentJob","currentNestingLevel","currentProgress","rootProgress","getRootProgress","reportProgress","state","progress","get","reportProgressDone","getCurrentProgressTracker","addChildTracker","undefined","addChildTask","capture","f","parentMessageSet","withValue","nestingLevel","start","Date","now","console","log","end","enterJob","progressOptions","forkJoin","originalJob","jobHasMessages","search","find","markBoundary","markBottom","error","downcase","slice","toLowerCase","Error","secondary","info","useMyCaller","parse","insideFiber","outsideFiber","concat","caller","exception","FancySyntaxError","parsed","locus","assertInJob","assertInCapture","mergeMessagesIntoCurrentJob","innerMessages","outerMessages","outerJob","iterable","fn","isFunction","enterJobAsync","Promise","resolve","reject","err","parallel","then","errors","results","args","promise","await","all","buildmessage","exports","_MessageSet"],"mappings":"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","file":"tools/utils/buildmessage.js.map","sourcesContent":["var _ = require('underscore');\nvar files = require('../fs/files.js');\nvar parseStack = require('./parse-stack.js');\nvar fiberHelpers = require('./fiber-helpers.js');\nvar Progress = require('../console/progress.js').Progress;\n\nvar debugBuild = !!process.env.METEOR_DEBUG_BUILD;\n\n// A job is something like \"building package foo\". It contains the set\n// of messages generated by tha job. A given build run could contain\n// several jobs. Each job has an (absolute) path associated with\n// it. Filenames in messages within a job are to be interpreted\n// relative to that path.\n//\n// Jobs are used both for error handling (via buildmessage.capture) and to set\n// the progress bar title (via progress.js).\n//\n// Job titles should begin with a lower-case letter (unless they begin with a\n// proper noun), so that they look correct in error messages which say \"While\n// jobbing the job\".  The first letter will be capitalized automatically for the\n// progress bar.\nvar Job = function (options) {\n  var self = this;\n  self.messages = [];\n\n  // Should be something like \"building package 'foo'\"\n  // Should look good in \"While $title:\\n[messages]\"\n  self.title = options.title;\n  self.rootPath = options.rootPath;\n\n  // Array of Job (jobs created inside this job)\n  self.children = [];\n};\n\n_.extend(Job.prototype, {\n  // options may include type (\"error\"), message, func, file, line,\n  // column, stack (in the format returned by parseStack.parse())\n  addMessage: function (options) {\n    var self = this;\n    self.messages.push(options);\n  },\n\n  hasMessages: function () {\n    var self = this;\n    return self.messages.length > 0;\n  },\n\n  hasMessageWithTag: function (tagName) {\n    var self = this;\n    return _.any(self.messages, function (message) {\n      return message.tags && _.has(message.tags, tagName);\n    });\n  },\n\n  // Returns a multi-line string suitable for displaying to the user\n  formatMessages: function (indent) {\n    var self = this;\n    var out = \"\";\n    var already = {};\n    indent = new Array((indent || 0) + 1).join(' ');\n\n    _.each(self.messages, function (message) {\n      var stack = message.stack || [];\n\n      var line = indent;\n      if (message.file) {\n        line+= message.file;\n        if (message.line) {\n          line += \":\" + message.line;\n          if (message.column) {\n            // XXX maybe exclude unless specifically requested (eg,\n            // for an automated tool that's parsing our output?)\n            line += \":\" + message.column;\n          }\n        }\n        line += \": \";\n      } else {\n        // not sure how to display messages without a filenanme.. try this?\n        line += \"error: \";\n      }\n      // XXX line wrapping would be nice..\n      line += message.message;\n      if (message.func && stack.length <= 1) {\n        line += \" (at \" + message.func + \")\";\n      }\n      line += \"\\n\";\n\n      if (stack.length > 1) {\n        _.each(stack, function (frame) {\n          // If a nontrivial stack trace (more than just the file and line\n          // we already complained about), print it.\n          var where = \"\";\n          if (frame.file) {\n            where += frame.file;\n            if (frame.line) {\n              where += \":\" + frame.line;\n              if (frame.column) {\n                where += \":\" + frame.column;\n              }\n            }\n          }\n\n          if (! frame.func && ! where) {\n            // that's a pretty lame stack frame\n            return;\n          }\n\n          line += \"  at \";\n          if (frame.func) {\n            line += frame.func + \" (\" + where + \")\\n\";\n          } else {\n            line += where + \"\\n\";\n          }\n        });\n        line += \"\\n\";\n      }\n\n      // Deduplicate messages (only when exact duplicates, including stack)\n      if (! (line in already)) {\n        out += line;\n        already[line] = true;\n      }\n    });\n\n    return out;\n  }\n\n});\n\n// A MessageSet contains a set of jobs, which in turn each contain a\n// set of messages.\nvar MessageSet = function (messageSet) {\n  var self = this;\n  self.jobs = [];\n\n  if (messageSet) {\n    self.jobs = _.clone(messageSet.jobs);\n  }\n};\n\n_.extend(MessageSet.prototype, {\n  formatMessages: function () {\n    var self = this;\n\n    var jobsWithMessages = _.filter(self.jobs, function (job) {\n      return job.hasMessages();\n    });\n\n    return _.map(jobsWithMessages, function (job) {\n      var out = '';\n      out += \"While \" + job.title + \":\\n\";\n      out += job.formatMessages(0);\n      return out;\n    }).join('\\n'); // blank line between jobs\n  },\n\n  hasMessages: function () {\n    var self = this;\n    return _.any(self.jobs, function (job) {\n      return job.hasMessages();\n    });\n  },\n\n  hasMessageWithTag: function (tagName) {\n    var self = this;\n    return _.any(self.jobs, function (job) {\n      return job.hasMessageWithTag(tagName);\n    });\n  },\n\n  // Copy all of the messages in another MessageSet into this\n  // MessageSet. If the other MessageSet is subsequently mutated,\n  // results are undefined.\n  //\n  // XXX rather than this, the user should be able to create a\n  // MessageSet and pass it into capture(), and functions such as\n  // bundle() should take and mutate, rather than return, a\n  // MessageSet.\n  merge: function (messageSet) {\n    var self = this;\n    _.each(messageSet.jobs, function (j) {\n      self.jobs.push(j);\n    });\n  }\n});\n\nvar spaces = function (n) {\n  return _.times(n, function() { return ' ' }).join('');\n};\n\n// XXX: This is now a little bit silly... ideas:\n// Can we just have one hierarchical state?\n// Can we combined job & messageSet\n// Can we infer nesting level?\nvar currentMessageSet = new fiberHelpers.EnvironmentVariable;\nvar currentJob = new fiberHelpers.EnvironmentVariable;\nvar currentNestingLevel = new fiberHelpers.EnvironmentVariable(0);\nvar currentProgress = new fiberHelpers.EnvironmentVariable;\n\nvar rootProgress = new Progress();\n\nvar getRootProgress = function () {\n  return rootProgress;\n};\n\nvar reportProgress = function (state) {\n  var progress = currentProgress.get();\n  if (progress) {\n    progress.reportProgress(state);\n  }\n};\n\nvar reportProgressDone = function () {\n  var progress = currentProgress.get();\n  if (progress) {\n    progress.reportProgressDone();\n  }\n};\n\nvar getCurrentProgressTracker = function () {\n  var progress = currentProgress.get();\n  return progress ? progress : rootProgress;\n};\n\nvar addChildTracker = function (title) {\n  var options = {};\n  if (title !== undefined) {\n    options.title = title;\n  }\n  return getCurrentProgressTracker().addChildTask(options);\n};\n\n// Create a new MessageSet, run `f` with that as the current\n// MessageSet for the purpose of accumulating and recovering from\n// errors (see error()), and then discard the return value of `f` and\n// return the MessageSet.\n//\n// Note that you must also create a job (with enterJob) to actually\n// begin capturing errors. Alternately you may pass `options`\n// (otherwise optional) and a job will be created for you based on\n// `options`.\nvar capture = function (options, f) {\n  var messageSet = new MessageSet;\n  var parentMessageSet = currentMessageSet.get();\n\n  var title;\n  if (typeof options === \"object\" && options.title) {\n    title = options.title;\n  }\n  var progress = addChildTracker(title);\n\n  currentProgress.withValue(progress, function () {\n    currentMessageSet.withValue(messageSet, function () {\n      var job = null;\n      if (typeof options === \"object\") {\n        job = new Job(options);\n        messageSet.jobs.push(job);\n      } else {\n        f = options; // options not actually provided\n      }\n\n      currentJob.withValue(job, function () {\n        var nestingLevel = currentNestingLevel.get();\n        currentNestingLevel.withValue(nestingLevel + 1, function () {\n          var start;\n          if (debugBuild) {\n            start = Date.now();\n            console.log(spaces(nestingLevel * 2), \"START CAPTURE\", nestingLevel, options.title, \"took \" + (end - start));\n          }\n          try {\n            f();\n          } finally {\n            progress.reportProgressDone();\n\n            if (debugBuild) {\n              var end = Date.now();\n              console.log(spaces(nestingLevel * 2), \"END CAPTURE\", nestingLevel, options.title, \"took \" + (end - start));\n            }\n          }\n        });\n      });\n    });\n  });\n  return messageSet;\n};\n\n// Called from inside capture(), creates a new Job inside the current\n// MessageSet and run `f` inside of it, so that any messages emitted\n// by `f` are logged in the Job. Returns the return value of `f`. May\n// be called recursively.\n//\n// Called not from inside capture(), does nothing (except call f).\n//\n// options:\n// - title: a title for the job (required)\n// - rootPath: the absolute path relative to which paths in messages\n//   in this job should be interpreted (omit if there is no way to map\n//   files that this job talks about back to files on disk)\nvar enterJob = function (options, f) {\n  if (typeof options === \"function\") {\n    f = options;\n    options = {};\n  }\n\n  if (typeof options === \"string\") {\n    options = {title: options};\n  }\n\n  var progress;\n  {\n    var progressOptions = {};\n    // XXX: Just pass all the options?\n    if (typeof options === \"object\") {\n      if (options.title) {\n        progressOptions.title = options.title;\n      }\n      if (options.forkJoin) {\n        progressOptions.forkJoin = options.forkJoin;\n      }\n    }\n    progress = getCurrentProgressTracker().addChildTask(progressOptions);\n  }\n\n  return currentProgress.withValue(progress, function () {\n    if (!currentMessageSet.get()) {\n      var nestingLevel = currentNestingLevel.get();\n      var start;\n      if (debugBuild) {\n        start = Date.now();\n        console.log(spaces(nestingLevel * 2), \"START\", nestingLevel, options.title);\n      }\n      try {\n        return currentNestingLevel.withValue(nestingLevel + 1, function () {\n          return f();\n        });\n      } finally {\n        progress.reportProgressDone();\n        if (debugBuild) {\n          var end = Date.now();\n          console.log(spaces(nestingLevel * 2), \"DONE\", nestingLevel, options.title, \"took \" + (end - start));\n        }\n      }\n    }\n\n    var job = new Job(options);\n    var originalJob = currentJob.get();\n    originalJob && originalJob.children.push(job);\n    currentMessageSet.get().jobs.push(job);\n\n    return currentJob.withValue(job, function () {\n      var nestingLevel = currentNestingLevel.get();\n      return currentNestingLevel.withValue(nestingLevel + 1, function () {\n        var start;\n        if (debugBuild) {\n          start = Date.now();\n          console.log(spaces(nestingLevel * 2), \"START\", nestingLevel, options.title);\n        }\n        try {\n          return f();\n        } finally {\n          progress.reportProgressDone();\n          if (debugBuild) {\n            var end = Date.now();\n            console.log(spaces(nestingLevel * 2), \"DONE\", nestingLevel, options.title, \"took \" + (end - start));\n          }\n        }\n      });\n    });\n  });\n};\n\n// If not inside a job, return false. Otherwise, return true if any\n// messages (presumably errors) have been recorded for this job\n// (including subjobs created inside this job), else false.\nvar jobHasMessages = function () {\n  var search = function (job) {\n    if (job.hasMessages()) {\n      return true;\n    }\n    return !! _.find(job.children, search);\n  };\n\n  return currentJob.get() ? search(currentJob.get()) : false;\n};\n\n// Given a function f, return a \"marked\" version of f. The mark\n// indicates that stack traces should stop just above f. So if you\n// mark a user-supplied callback function before calling it, you'll be\n// able to show the user just the \"user portion\" of the stack trace\n// (the part inside their own code, and not all of the innards of the\n// code that called it).\nvar markBoundary = function (f) {\n  return parseStack.markBottom(f);\n};\n\n// Record a build error. If inside a job, add the error to the current\n// job and return (caller should do its best to recover and\n// continue). Otherwise, throws an exception based on the error.\n//\n// options may include\n// - file: the file containing the error, relative to the root of the build\n//   (this must be agreed upon out of band)\n// - line: the (1-indexed) line in the file that contains the error\n// - column: the (1-indexed) column in that line where the error begins\n// - func: the function containing the code that triggered the error\n// - useMyCaller: true to capture information the caller (function\n//   name, file, and line). It captures not the information of the\n//   caller of error(), but that caller's caller. It saves them in\n//   'file', 'line', and 'column' (overwriting any values passed in\n//   for those). It also captures the user portion of the stack,\n//   starting at and including the caller's caller.\n//   If this is a number instead of 'true', skips that many stack frames.\n// - downcase: if true, the first character of `message` will be\n//   converted to lower case.\n// - secondary: ignore this error if there are are already other\n//   errors in this job (the implication is that it's probably\n//   downstream of the other error, ie, a consequence of our attempt\n//   to continue past other errors)\n// - tags: object with other error-specific data; there is a method\n//   on MessageSet which can search for errors with a specific named\n//   tag.\nvar error = function (message, options) {\n  options = options || {};\n\n  if (options.downcase) {\n    message = message.slice(0,1).toLowerCase() + message.slice(1);\n  }\n\n  if (! currentJob.get()) {\n    throw new Error(\"Error: \" + message);\n  }\n\n  if (options.secondary && jobHasMessages()) {\n    // skip it\n    return;\n  }\n\n  var info = _.extend({\n    message: message\n  }, options);\n\n  if ('useMyCaller' in info) {\n    if (info.useMyCaller) {\n      const {\n        insideFiber,\n        outsideFiber\n      } = parseStack.parse(new Error());\n\n      // Concatenate and get rid of lines about Future and buildmessage\n      info.stack = outsideFiber.concat(insideFiber || []).slice(2);\n      if (typeof info.useMyCaller === 'number') {\n        info.stack = info.stack.slice(info.useMyCaller);\n      }\n      var caller = info.stack[0];\n      info.func = caller.func;\n      info.file = caller.file;\n      info.line = caller.line;\n      info.column = caller.column;\n    }\n    delete info.useMyCaller;\n  }\n\n  currentJob.get().addMessage(info);\n};\n\n// Record an exception. The message as well as any file and line\n// information be read directly out of the exception. If not in a job,\n// throws the exception instead. Also capture the user portion of the stack.\n//\n// There is special handling for files.FancySyntaxError exceptions. We\n// will grab the file and location information where the syntax error\n// actually occurred, rather than the place where the exception was\n// thrown.\nvar exception = function (error) {\n  if (! currentJob.get()) {\n    // XXX this may be the wrong place to do this, but it makes syntax errors in\n    // files loaded via isopack.load have context.\n    if (error instanceof files.FancySyntaxError) {\n      error = new Error(\"Syntax error: \" + error.message + \" at \" +\n        error.file + \":\" + error.line + \":\" + error.column);\n    }\n    throw error;\n  }\n\n  var message = error.message;\n\n  if (error instanceof files.FancySyntaxError) {\n    // No stack, because FancySyntaxError isn't a real Error and has no stack\n    // property!\n    currentJob.get().addMessage({\n      message: message,\n      file: error.file,\n      line: error.line,\n      column: error.column\n    });\n  } else {\n    var parsed = parseStack.parse(error);\n\n    // If there is a part inside the fiber, that's the one we want. Otherwise,\n    // use the one outside.\n    var stack = parsed.insideFiber || parsed.outsideFiber;\n    if (stack && stack.length > 0) {\n      var locus = stack[0];\n      currentJob.get().addMessage({\n        message: message,\n        stack: stack,\n        func: locus.func,\n        file: locus.file,\n        line: locus.line,\n        column: locus.column\n      });\n    } else {\n      currentJob.get().addMessage({\n        message: message\n      });\n    }\n  }\n};\n\nvar assertInJob = function () {\n  if (! currentJob.get()) {\n    throw new Error(\"Expected to be in a buildmessage job\");\n  }\n};\n\nvar assertInCapture = function () {\n  if (! currentMessageSet.get()) {\n    throw new Error(\"Expected to be in a buildmessage capture\");\n  }\n};\n\nvar mergeMessagesIntoCurrentJob = function (innerMessages) {\n  var outerMessages = currentMessageSet.get();\n  if (! outerMessages) {\n    throw new Error(\"Expected to be in a buildmessage capture\");\n  }\n  var outerJob = currentJob.get();\n  if (! outerJob) {\n    throw new Error(\"Expected to be in a buildmessage job\");\n  }\n  _.each(innerMessages.jobs, function (j) {\n    outerJob.children.push(j);\n  });\n  outerMessages.merge(innerMessages);\n};\n\n// Like _.each, but runs each operation in a separate job\nvar forkJoin = function (options, iterable, fn) {\n  if (!_.isFunction(fn)) {\n    fn = iterable;\n    iterable = options;\n    options = {};\n  }\n\n  options.forkJoin = true;\n\n  function enterJobAsync(options) {\n    return new Promise((resolve, reject) => {\n      enterJob(options, err => {\n        err ? reject(err) : resolve();\n      });\n    });\n  }\n\n  const parallel = (options.parallel !== undefined) ? options.parallel : true;\n\n  return enterJobAsync(options).then(() => {\n    const errors = [];\n    let results = _.map(iterable, (...args) => {\n      const promise = enterJobAsync({\n        title: (options.title || \"\") + \" child\"\n      }).then(() => fn(...args))\n        // Collect any errors thrown (and later re-throw the first one),\n        // but don't stop processing remaining jobs.\n        .catch(error => (errors.push(error), null));\n\n      if (parallel) {\n        // If the jobs are intended to run in parallel, return each\n        // promise without awaiting it, so that Promise.all can wait for\n        // them all to be fulfilled.\n        return promise;\n      }\n\n      // By awaiting the promise during each iteration, we effectively\n      // serialize the execution of the jobs.\n      return promise.await();\n    });\n\n    if (parallel) {\n      // If the jobs ran in parallel, then results is an array of Promise\n      // objects that still need to be resolved.\n      results = Promise.all(results).await();\n    }\n\n    if (errors.length > 0) {\n      // If any errors were thrown, re-throw the first one. Note that this\n      // allows jobs to complete successfully (and have whatever\n      // side-effects they should have) after the first error is thrown,\n      // though the final results will not be returned below.\n      throw errors[0];\n    }\n\n    return results;\n  }).await();\n};\n\n\nvar buildmessage = exports;\n_.extend(exports, {\n  capture: capture,\n  enterJob: enterJob,\n  markBoundary: markBoundary,\n  error: error,\n  exception: exception,\n  jobHasMessages: jobHasMessages,\n  assertInJob: assertInJob,\n  assertInCapture: assertInCapture,\n  mergeMessagesIntoCurrentJob: mergeMessagesIntoCurrentJob,\n  forkJoin: forkJoin,\n  getRootProgress: getRootProgress,\n  reportProgress: reportProgress,\n  reportProgressDone: reportProgressDone,\n  getCurrentProgressTracker: getCurrentProgressTracker,\n  addChildTracker: addChildTracker,\n  _MessageSet: MessageSet\n});\n"]}