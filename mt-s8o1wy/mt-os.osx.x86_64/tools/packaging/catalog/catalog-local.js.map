{"version":3,"sources":["/tools/packaging/catalog/catalog-local.js"],"names":["_","require","buildmessage","files","watch","PackageSource","KNOWN_ISOBUILD_FEATURE_PACKAGES","sync","glob","Profile","optimisticHashOrNull","LocalCatalog","options","self","packages","initialized","localPackageSearchDirs","explicitlyAddedLocalPackageDirs","effectiveLocalPackageDirs","packageLocationWatchSet","WatchSet","_nextId","extend","prototype","toString","JSON","stringify","initialize","assertInCapture","addPatternsToList","patterns","list","forEach","process","platform","pattern","convertToOSPath","charAt","slice","convertToPosixPath","push","pathResolve","p","_computeEffectiveLocalPackages","_loadLocalPackages","buildingIsopackets","_requireInitialized","Error","getAllPackageNames","keys","getAllNonTestPackageNames","includeNonCore","ret","nonCoreDir","pathJoin","getCurrentToolsDir","pathSep","each","name","sourceRoot","packageSource","isTest","versionRecord","startsWith","getPackage","has","packageRecord","getSortedVersions","version","getSortedVersionRecords","map","packageName","dependencies","getVersion","getLatestVersion","getVersionBySourceRoot","packageObj","find","enterJob","explicitDir","packageJsPath","packageJsHash","addFile","error","file","searchDir","possiblePackageDirs","readAndWatchDirectory","absPath","include","subdir","substr","length","absPackageDir","initSourceFromDir","packageDir","definiteName","title","rootPath","initFromPackageDirOptions","initFromPackageDir","jobHasMessages","_id","maintainers","lastUpdated","testName","publishedBy","description","metadata","summary","git","getDependencyMetadata","source","published","debugOnly","prodOnly","testOnly","containsPlugins","forkJoin","parallel","dir","getPackageSource","method","exports"],"mappings":"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","file":"tools/packaging/catalog/catalog-local.js.map","sourcesContent":["var _ = require('underscore');\nvar buildmessage = require('../../utils/buildmessage.js');\nvar files = require('../../fs/files.js');\nvar watch = require('../../fs/watch.js');\nvar PackageSource = require('../../isobuild/package-source.js');\nimport { KNOWN_ISOBUILD_FEATURE_PACKAGES } from '../../isobuild/compiler.js';\nimport { sync as glob } from \"glob\";\nimport { Profile } from \"../../tool-env/profile.js\";\nimport {\n  optimisticHashOrNull,\n} from \"../../fs/optimistic.js\";\n\n// LocalCatalog represents packages located in the application's\n// package directory, other package directories specified via an\n// environment variable, and core packages in the repo if meteor is\n// being run from a git checkout.\nvar LocalCatalog = function (options) {\n  var self = this;\n  options = options || {};\n\n  // Package server data.  Maps package name to a {packageSource, packageRecord,\n  // versionRecord} object.\n  self.packages = {};\n\n  self.initialized = false;\n\n    // Local directories to search for package source trees\n  self.localPackageSearchDirs = null;\n\n  // Package source trees added explicitly through a directory (not through a\n  // parent search directory). We mainly use this to allow the user to run\n  // test-packages against a package in a specific directory.\n  self.explicitlyAddedLocalPackageDirs = [];\n\n  // All packages found either by localPackageSearchDirs or\n  // explicitlyAddedLocalPackageDirs. There is a hierarchy of packages, as\n  // detailed below and there can only be one local version of a package at a\n  // time. This refers to the package by the specific package directory that we\n  // need to process.\n  self.effectiveLocalPackageDirs = [];\n\n  // A WatchSet that detects when the set of packages and their locations\n  // changes. ie, the listings of 'packages' directories, and the contents of\n  // package.js files underneath.  It does NOT track the rest of the source of\n  // the packages: that wouldn't be helpful to the runner since it would be too\n  // coarse to tell if a change is client-only or not.  (But any change to the\n  // layout of where packages live counts as a non-client-only change.)\n  self.packageLocationWatchSet = new watch.WatchSet;\n\n  self._nextId = 1;\n};\n\n_.extend(LocalCatalog.prototype, {\n  toString: function () {\n    var self = this;\n    return \"LocalCatalog [localPackageSearchDirs=\" +\n      JSON.stringify(self.localPackageSearchDirs) + \"]\";\n  },\n\n  // Initialize the Catalog. This must be called before any other\n  // Catalog function.\n\n  // options:\n  //  - localPackageSearchDirs: an array of paths on local disk, that contain\n  //    subdirectories, that each contain a source tree for a package that\n  //    should override the packages on the package server. For example, if\n  //    there is a package 'foo' that we find through localPackageSearchDirs,\n  //    then we will ignore all versions of 'foo' that we find through the\n  //    package server. Directories that don't exist (or paths that aren't\n  //    directories) will be silently ignored.\n  //  - explicitlyAddedLocalPackageDirs: an array of paths which THEMSELVES\n  //    are package source trees.  Takes precedence over packages found\n  //    via localPackageSearchDirs.\n  //  - buildingIsopackets: true if we are building isopackets\n  initialize(options) {\n    var self = this;\n    buildmessage.assertInCapture();\n\n    options = options || {};\n\n    const addPatternsToList =\n      Profile(\"addPatternsToList\", (patterns, list) => {\n        if (! patterns) {\n          return;\n        }\n\n        patterns.forEach(pattern => {\n          if (process.platform === \"win32\") {\n            pattern = files.convertToOSPath(pattern);\n\n            if (pattern.charAt(1) === \":\") {\n              // Get rid of drive prefix, e.g. C:\n              pattern = pattern.slice(2);\n            }\n\n            // Convert to /forward/slash/path without /C\n            pattern = files.convertToPosixPath(pattern, true);\n          }\n\n          // Note: glob expects POSIX-style paths, even on Windows.\n          // https://github.com/isaacs/node-glob/blob/master/README.md#windows\n          glob(pattern).forEach(\n            p => list.push(files.pathResolve(p))\n          );\n        });\n      });\n\n    addPatternsToList(\n      options.localPackageSearchDirs,\n      self.localPackageSearchDirs = [],\n    );\n\n    addPatternsToList(\n      options.explicitlyAddedLocalPackageDirs,\n      self.explicitlyAddedLocalPackageDirs = [],\n    );\n\n    self._computeEffectiveLocalPackages();\n    self._loadLocalPackages(options.buildingIsopackets);\n    self.initialized = true;\n  },\n\n  // Throw if the catalog's self.initialized value has not been set to true.\n  _requireInitialized: function () {\n    var self = this;\n\n    if (! self.initialized)\n      throw new Error(\"catalog not initialized yet?\");\n  },\n\n  // Return an array with the names of all of the packages that we know about,\n  // in no particular order.\n  getAllPackageNames: function (options) {\n    var self = this;\n    self._requireInitialized();\n\n    return _.keys(self.packages);\n  },\n\n  // Return an array with the names of all of the non-test packages that we know\n  // about, in no particular order.\n  getAllNonTestPackageNames: function ({\n    // Iff options.includeNonCore is truthy, packages in\n    // meteor/packages/non-core/*/packages will be returned.\n    includeNonCore = true,\n  } = {}) {\n    var self = this;\n    self._requireInitialized();\n\n    var ret = [];\n\n    const nonCoreDir = files.pathJoin(\n      files.getCurrentToolsDir(),\n      \"packages\",\n      \"non-core\"\n    ) + files.pathSep;\n\n    _.each(self.packages, function ({\n      packageSource: { sourceRoot },\n      versionRecord: { isTest },\n    }, name) {\n      if (isTest) {\n        return;\n      }\n\n      if (! includeNonCore &&\n          sourceRoot.startsWith(nonCoreDir)) {\n        return;\n      }\n\n      ret.push(name);\n    });\n\n    return ret;\n  },\n\n  // Returns general (non-version-specific) information about a\n  // package, or null if there is no such package.\n  getPackage: function (name, options) {\n    var self = this;\n    self._requireInitialized();\n    options = options || {};\n\n    if (!_.has(self.packages, name))\n      return null;\n    return self.packages[name].packageRecord;\n  },\n\n  // Given a package, returns an array of the versions available (ie, the one\n  // version we have, or an empty array).\n  getSortedVersions: function (name) {\n    var self = this;\n    self._requireInitialized();\n\n    if (!_.has(self.packages, name))\n      return [];\n    return [self.packages[name].versionRecord.version];\n  },\n\n  // Given a package, returns an array of the version records available (ie, the\n  // one version we have, or an empty array). This method is intended for use by\n  // Version Solver's CatalogLoader.\n  //\n  // As a special case, if name is an isobuild:* pseudo-package, returns\n  // (minimal) information about it as well.\n  getSortedVersionRecords: function (name) {\n    var self = this;\n    self._requireInitialized();\n\n    if (_.has(KNOWN_ISOBUILD_FEATURE_PACKAGES, name)) {\n      return KNOWN_ISOBUILD_FEATURE_PACKAGES[name].map(\n        version => ({version, packageName: name, dependencies: {}})\n      );\n    }\n\n    if (!_.has(self.packages, name))\n      return [];\n    return [self.packages[name].versionRecord];\n  },\n\n  // Return information about a particular version of a package, or\n  // null if there is no such package or version.\n  getVersion: function (name, version) {\n    var self = this;\n    self._requireInitialized();\n\n    if (!_.has(self.packages, name))\n      return null;\n    var versionRecord = self.packages[name].versionRecord;\n    if (versionRecord.version !== version)\n      return null;\n    return versionRecord;\n  },\n\n  // As getVersion, but returns info on the latest version of the\n  // package, or null if the package doesn't exist or has no versions.\n  getLatestVersion: function (name) {\n    var self = this;\n\n    if (!_.has(self.packages, name))\n      return null;\n    return self.packages[name].versionRecord;\n  },\n\n  getVersionBySourceRoot: function (sourceRoot) {\n    var self = this;\n    var packageObj = _.find(self.packages, function (p) {\n      return p.packageSource.sourceRoot === sourceRoot;\n    });\n    if (! packageObj)\n      return null;\n    return packageObj.versionRecord;\n  },\n\n  // Compute self.effectiveLocalPackageDirs from self.localPackageSearchDirs and\n  // self.explicitlyAddedLocalPackageDirs.\n  _computeEffectiveLocalPackages() {\n    var self = this;\n    buildmessage.assertInCapture();\n\n    self.effectiveLocalPackageDirs = [];\n\n    buildmessage.enterJob(\"looking for packages\", function () {\n      _.each(self.explicitlyAddedLocalPackageDirs, (explicitDir) => {\n        const packageJsPath = files.pathJoin(explicitDir, \"package.js\");\n        const packageJsHash = optimisticHashOrNull(packageJsPath);\n\n        if (packageJsHash) {\n          self.packageLocationWatchSet.addFile(\n            packageJsPath,\n            packageJsHash,\n          );\n\n          self.effectiveLocalPackageDirs.push(explicitDir);\n\n        } else {\n          // We asked specifically for this directory, but it has no package!\n          buildmessage.error(\"package has no package.js file\", {\n            file: explicitDir\n          });\n        }\n      });\n\n      _.each(self.localPackageSearchDirs, function (searchDir) {\n        var possiblePackageDirs = watch.readAndWatchDirectory(\n          self.packageLocationWatchSet, {\n            absPath: searchDir,\n            include: [/\\/$/]\n          });\n        // Not a directory? Ignore.\n        if (possiblePackageDirs === null)\n          return;\n\n        _.each(possiblePackageDirs, function (subdir) {\n          // readAndWatchDirectory adds a slash to the end of directory names to\n          // differentiate them from filenames. Remove it.\n          subdir = subdir.substr(0, subdir.length - 1);\n          var absPackageDir = files.pathJoin(searchDir, subdir);\n\n          // Consider a directory to be a package source tree if it contains\n          // 'package.js'. (We used to support isopacks in\n          // localPackageSearchDirs, but no longer.)\n\n          const packageJsPath = files.pathJoin(absPackageDir, \"package.js\");\n          const packageJsHash = optimisticHashOrNull(packageJsPath);\n\n          if (packageJsHash) {\n            // Let earlier package directories override later package\n            // directories.\n            self.packageLocationWatchSet.addFile(\n              packageJsPath,\n              packageJsHash,\n            );\n\n            // We don't know the name of the package, so we can't deal with\n            // duplicates yet. We are going to have to rely on the fact that we\n            // are putting these in in order, to be processed in order.\n            self.effectiveLocalPackageDirs.push(absPackageDir);\n          }\n        });\n      });\n    });\n  },\n\n  _loadLocalPackages(buildingIsopackets) {\n    var self = this;\n    buildmessage.assertInCapture();\n\n    // Load the package source from a directory. We don't know the names of our\n    // local packages until we do this.\n    //\n    // THIS MUST BE RUN IN LOAD ORDER. Let's say that we have two directories\n    // for mongo-livedata. The first one processed by this function will be\n    // canonical.  The second one will be ignored.\n    //\n    // (note: this is the behavior that we want for overriding things in\n    //  checkout.  It is not clear that you get good UX if you have two packages\n    //  with the same name in your app. We don't check that.)\n    var initSourceFromDir = function (packageDir, definiteName) {\n      var packageSource = new PackageSource;\n      buildmessage.enterJob({\n        title: \"reading package from `\" + packageDir + \"`\",\n        rootPath: packageDir\n      }, function () {\n        var initFromPackageDirOptions = {\n          buildingIsopackets: !! buildingIsopackets\n        };\n        // If we specified a name, then we know what we want to get and should\n        // pass that into the options. Otherwise, we will use the 'name'\n        // attribute from package-source.js.\n        if (definiteName) {\n          initFromPackageDirOptions.name = definiteName;\n        }\n        packageSource.initFromPackageDir(packageDir, initFromPackageDirOptions);\n        if (buildmessage.jobHasMessages())\n          return;  // recover by ignoring\n\n        // Now that we have initialized the package from package.js, we know its\n        // name.\n        var name = packageSource.name;\n\n        // We should only have one package dir for each name; in this case, we\n        // are going to take the first one we get (since we preserved the order\n        // in which we loaded local package dirs when running this function.)\n        if (_.has(self.packages, name))\n          return;\n\n        self.packages[name] = {\n          packageSource: packageSource,\n          packageRecord: {\n            _id: \"PID\" + self._nextId++,\n            name: name,\n            maintainers: null,\n            lastUpdated: null\n          },\n          versionRecord: {\n            _id: \"VID\" + self._nextId++,\n            packageName: name,\n            testName: packageSource.testName,\n            version: packageSource.version,\n            publishedBy: null,\n            description: packageSource.metadata.summary,\n            git: packageSource.metadata.git,\n            dependencies: packageSource.getDependencyMetadata(),\n            source: null,\n            lastUpdated: null,\n            published: null,\n            isTest: packageSource.isTest,\n            debugOnly: packageSource.debugOnly,\n            prodOnly: packageSource.prodOnly,\n            testOnly: packageSource.testOnly,\n            containsPlugins: packageSource.containsPlugins()\n          }\n        };\n\n        // If this is NOT a test package AND it has tests (tests will be\n        // marked as test packages by package source, so we will not recurse\n        // infinitely), then process that too.\n        if (!packageSource.isTest && packageSource.testName) {\n          initSourceFromDir(packageSource.sourceRoot, packageSource.testName);\n        }\n      });\n    };\n\n    // Load the package sources for packages and their tests into\n    // self.packages.\n    //\n    // XXX We should make this work with parallel: true; right now it seems to\n    // hit node problems.\n    buildmessage.forkJoin(\n      { 'title': 'initializing packages', parallel: false },\n      self.effectiveLocalPackageDirs,\n      function (dir) {\n        initSourceFromDir(dir);\n      });\n  },\n\n  getPackageSource: function (name) {\n    var self = this;\n    if (! _.has(self.packages, name))\n      return null;\n    return self.packages[name].packageSource;\n  }\n});\n\n[\"initialize\",\n \"_computeEffectiveLocalPackages\",\n \"_loadLocalPackages\",\n].forEach(function (method) {\n  this[method] = Profile(\"LocalCatalog#\" + method, this[method]);\n}, LocalCatalog.prototype);\n\nexports.LocalCatalog = LocalCatalog;\n"]}