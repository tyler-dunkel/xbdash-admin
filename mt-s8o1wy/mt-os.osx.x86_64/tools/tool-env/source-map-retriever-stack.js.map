{"version":3,"sources":["/tools/tool-env/source-map-retriever-stack.js"],"names":["sourceMapSupport","stack","push","func","tryAllSourceMapRetrievers","filename","i","length","sourceMapData","wrapCallSite","unwrappedFrame","frame","wrapGetter","name","origGetter","arg","source","replace","install","retrieveSourceMap","handleUncaughtExceptions","Error","METEOR_prepareStackTrace","prepareStackTrace"],"mappings":"AAAA,OAAOA,gBAAP,MAA6B,oBAA7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAMC,QAAQ,EAAd;;AAEA;AACA;AACA,OAAO,SAASC,IAAT,CAAcC,IAAd,EAAoB;AACzBF,QAAMC,IAAN,CAAWC,IAAX;AACD;;AAED,SAASC,yBAAT,CAAmCC,QAAnC,EAA6C;AAC3C,OAAK,IAAIC,IAAIL,MAAMM,MAAN,GAAe,CAA5B,EAA+BD,KAAK,CAApC,EAAuCA,GAAvC,EAA4C;AAC1C,QAAME,gBAAgBP,MAAMK,CAAN,EAASD,QAAT,CAAtB;;AAEA,QAAIG,aAAJ,EAAmB;AACjB,aAAOA,aAAP;AACD;AACF;;AAED,SAAO,IAAP;AACD;;AAED,SAASC,YAAT,CAAsBC,cAAtB,EAAsC;AACpC,MAAMC,QAAQX,iBAAiBS,YAAjB,CAA8BC,cAA9B,CAAd;AACA,WAASE,UAAT,CAAoBC,IAApB,EAA0B;AACxB,QAAMC,aAAaH,MAAME,IAAN,CAAnB;AACAF,UAAME,IAAN,IAAc,UAASE,GAAT,EAAc;AAC1B;AACA;AACA,UAAMC,SAASF,WAAWC,GAAX,CAAf;AACA,UAAI,CAACC,MAAL,EAAa;AACX,eAAOA,MAAP;AACD;AACD,aAAOA,OAAOC,OAAP,CAAe,0BAAf,EAA2C,IAA3C,CAAP;AACD,KARD;AASD;AACDL,aAAW,0BAAX;AACAA,aAAW,eAAX;;AAEA,SAAOD,KAAP;AACD;;AAGDX,iBAAiBkB,OAAjB,CAAyB;AACvBC,qBAAmBf,yBADI;AAEvB;AACA;AACA;AACA;AACA;AACAgB,4BAA0B,KAPH;AAQvBX;AARuB,CAAzB;;AAWA;AACA;AACAY,MAAMC,wBAAN,GAAiCD,MAAME,iBAAvC;;AAEA;;AAEA;AACArB,KAAKF,iBAAiBmB,iBAAtB;;AAEA;;AAEA","file":"tools/tool-env/source-map-retriever-stack.js.map","sourcesContent":["import sourceMapSupport from 'source-map-support';\n\n// Why this file exists:\n// We have two places in the tool where we need to do source maps:\n// 1. Loaded isopacks, which use a special custom source map cache\n// 2. Transpiled tool code from Babel\n//\n// In order to avoid crazy bootstrapping, it would be nice to be able to add\n// functions to look for source maps, so that we can call\n// sourceMapSupport.install as early as possible, and not worry about having\n// the right data structures around.\n//\n// This module maintains a stack of source map retrieval functions, which are\n// called in reverse order until one returns a truthy value.\n\nconst stack = [];\n\n// Add a function to locate source maps; all of the functions are executed in\n// reverse order\nexport function push(func) {\n  stack.push(func);\n}\n\nfunction tryAllSourceMapRetrievers(filename) {\n  for (let i = stack.length - 1; i >= 0; i--) {\n    const sourceMapData = stack[i](filename);\n\n    if (sourceMapData) {\n      return sourceMapData;\n    }\n  }\n\n  return null;\n}\n\nfunction wrapCallSite(unwrappedFrame) {\n  const frame = sourceMapSupport.wrapCallSite(unwrappedFrame);\n  function wrapGetter(name) {\n    const origGetter = frame[name];\n    frame[name] = function(arg) {\n      // replace a custom location domain that we set for better UX in Chrome\n      // DevTools (separate domain group) in source maps.\n      const source = origGetter(arg);\n      if (!source) {\n        return source;\n      }\n      return source.replace(/(^|\\()meteor:\\/\\/..app\\//, '$1');\n    };\n  }\n  wrapGetter('getScriptNameOrSourceURL');\n  wrapGetter('getEvalOrigin');\n\n  return frame;\n}\n\n\nsourceMapSupport.install({\n  retrieveSourceMap: tryAllSourceMapRetrievers,\n  // Disable the feature of source-map-support that shows an accurate snippet\n  // of source code on uncaught exception, because we haven't fixed it to\n  // be able to locate the proper source code to display.  (Note that the\n  // stack trace of an uncaught exception will be correctly source-mapped\n  // independent of this option.)\n  handleUncaughtExceptions: false,\n  wrapCallSite\n});\n\n// Save the correct prepareStackTrace so that if third-party code overwrites\n// it (ahem, coffeescript), we can restore it.\nError.METEOR_prepareStackTrace = Error.prepareStackTrace;\n\n// Default retrievers\n\n// Always fall back to the default in the end\npush(sourceMapSupport.retrieveSourceMap);\n\n/* eslint-disable max-len */\n\n/* eslint-enable max-len */\n"]}